% vim:ts=1:et:nospell:spelllang=en_gb:ft=tex

 \chapter{Related work}

  \emph{This chapter's content is largely based on ``MindXpres: An Extensible
  Content-driven Cross-Media Presentation Platform'' \citep{roels-1}.}

  \section{Background}

   The importance of digital presentations in this day and age cannot be
   understated. Millions of presentations are created every day, supporting the
   oral transfer of knowledge and playing an important role in educational
   settings. Their origins as tools for creating physical media such as
   photographic slides or transparencies for overhead projectors are still
   reflected in the underlying concepts and principles of slide-based
   presentation tools. The rectangular boundaries of a slide, and the linear
   navigation between slides, are still restrictions we face today in digital
   presentations. Tufte argues that these concepts of slideware have a negative
   impact on the effectiveness of knowledge transfer \citep{tufte-1}. While
   the presenter is compelled to squeeze complex ideas into a linear sequence
   of slides, those ideas are rarely sequential by nature, resulting in a loss
   of relations, overview and details. An initial approach to address these
   issues might involve creating minimalistic presentations or introducing some
   structure via a table of contents. Sadly, when complex knowledge or other
   pieces of rich information need to be presented “as is” \citep{farkas-1} ---
   as in the domain of education --- this does not work.

   Consider for example a course on the finer concepts of mathematics, or
   programming algorithms, where we have to understand the separate parts in no
   specific order, before understanding the whole. Some people may grasp one
   part's concept immediately, while others need more detailed explanation and
   yet others want to see the bigger picture to understand the purposeof the
   parts. While a sequence of slides may help to illustrate certain aspects, it
   is necessary to return to the overview regularly, which cannot be done
   without duplicating one or several slides.

   One of the main issues with traditional slideware presentations is their
   monolithic nature, especially when content is spread over many
   self-contained presentation files. ``Reusing'' previous work involves either
   switching between files while giving a presentation or duplicating some
   slides in the new presentation. It should be noted that this issue is not
   limited to the reuse of single slides: there is an ever increasing wealth of
   resources available for reuse, spread over a wide spectrum of distribution
   channels and formats. The possibility to include content by reference or
   transclusion \citep{nelson-1} may contribute in crossing the boundaries
   between different types of media and prove beneficial in the context of
   modern cross-media presentation tools.

   The difference in functionality between the authoring of content and its
   visualisation is striking as well. The primary editors consist of mostly
   toolbars and buttons used for selecting and specifying the way content
   should be visualised, while support for authoring the content itself is not
   quite as extensive. Modern slideware has grown to include basic multimedia
   types such as videos, but most content is still rather static. It is, for
   example, not possible during a presentation to easily switch from a bar
   chart to a pie chart data visualisation, or to dynamically change some
   values in the represented data and immediately see the effect in the graph,
   which could be beneficial for knowledge transfer \citep{holzinger-1}. The
   audience could also be more actively involved in the presentation, through
   audience response and classroom connectivity systems providing multi-device
   interfaces allowing to share knowledge and results during, as well as after,
   a presentation. The evolution of presentations is reminiscent of the Web2.0
   movements, where users have switched roles from purely consuming content to
   contributing as well, content has become more dynamic and interactive, and
   service-oriented architectures (``The Cloud'') have ensured decentralisation
   of content.

   In order to move a step towards the next generation of cross-media
   presentation tools, it is essential to allow the rapid prototyping and
   evaluation of new concepts for the representation, visualisation and
   interaction with content.

   Before discussing the requirements for a new generation of presentation
   tools, we briefly introduce existing slideware solutions. Afterwards, we
   describe the architecture of \mxp, its extensible nature and its plug-in
   mechanism. The HTML5-based implementation of \mxp is then discussed through
   demonstration of several use cases and \mxp plug-ins.

   A specific issue with slideware we'd like to focus on in this thesis, is the
   trouble with layout in presentations. It can be hard to display the content
   you want in a way that is clear, informative and nice to look at. The vast
   majority of layouts created today is mostly done by hand: a human graphic
   designer or ``layout expert'' makes most, if not all, of the decisions about
   the position and size of the objects to be presented \citep{lok-1}. Most
   software offers some templates, allowing you to drop pictures and text into
   predefined slots and places on a slide, but then those templates have been
   defined by someone else too. Computer-generated layout is rare and usually
   not quite up to the task.

   \mxp is among the software packages offering templates, in that layout is
   handled by whichever plug-in you choose, but so far no plug-ins have defined
   dynamic layout algorithms, rather sticking to predefined ways to put text
   and pictures on slides. But as \mxp does not constrain us to the limits of
   slides, this should be seen as an opportunity to offer dynamic layout as
   well. After all, if we are not limited to a certain area within which our
   content should fit, it should be much easier to put content next to each
   other in a way that makes sense.

  \section{Existing presentation solutions}

   Since digital slideware was first introduced, their influence, advantages
   and disadvantages have been studied extensively. There have been studies
   acknowledging the benefits of slideware as a teaching asset
   \citep{holzinger-1}, while others have been less positive. Tufte
   \citeyearpar{tufte-1} heavily criticises slideware for its infatuation with
   outdated concepts. He discusses the many ramifications of dimensional and
   structural limitations as well as linear navigation, and points out the
   discrepancy with how the human mind works. Amongst Tufte's conclusions, and
   also confirmed by Adams \citep{adams-1}, is the suggestion that slide-based
   presentations are not appropriate for every kind of knowledge transfer and
   especially not in a scientific context. Recent work shows the importance
   towards the learning process of integrating content into the bigger picture,
   both structurally and visually \citep{gross-1}, which is affected by the
   navigation and visualisation.

   Several approaches have been proposed to offer non-linear navigation.
   CounterPoint \citep{good-1}, Fly \citep{lichtschlag-1} and Prezi, provide
   Zoomable User Interfaces (ZUIs) which offer virtually unlimited space.
   Microsoft has experimented with this concept as well in pptPlex. Other
   approaches to escape the confines of the slide have been noticed, like
   MultiPresenter \citep{lanir-1} or tiling slideshows \citep{chen-1}.
   PaperPoint \citep{signer-1} and Palette \citep{nelson-2} additionally
   facilitate the non-linear navigation of digital presentations consisting of
   slide selection through augmented paper-based interfaces. Lastly, a category
   of authoring tools exists which use hypermedia to implement varying paths
   through a set of slides. NextSlidePlease \citep{spicer-1} enables users to
   define a weighted graph of slides, and tries to suggest navigational paths
   based on the link weights and the remaining presentation time. Microsoft
   cultivates this idea in their HyperSlides \citep{edge-1} project. Garcia
   \citep{garcia-1} has additionally explored the potential of \ppt* as an
   authoring tool for hypermedia-based presentations.

   \ppt* was officially released in 1990, with Windows 3.0 \citep{austin-1}. It
   had originally been developed as Presenter, but trademark issues caused a
   name change early on. It was also originally build for the Macintosh, which
   may seem surprising nowadays but was actually common practice back then
   since the Macintosh was widely regarded as a better development environment,
   more mature, more stable and capable of far better performance and
   visualisations. Some may argue this still rings true today.

   Since then, it has grown to be the world's most popular slide show
   presentation program, alledgedly having been installed on over 1 billion
   computers worldwide, and being used on average 350 times \emph{per second}
   \citep{parks-1}. In 2012, it had a market share of 95\%, leaving the other
   5\% to be shared by alternatives such as Apple's Keynote, Prezi, SlideRocket
   and others. While this number is declining, it may not be going as fast as
   many people think. As most readers of this thesis have heard before, over 30
   million \ppt presentations are created every day, for all kinds of purposes,
   with good and bad results both presentation-wise and goal-wise.

   To reuse content in existing presentation tools, that content needs to be
   duplicated, which results in a multitude of redundant copies that need to be
   kept consistent with each other: if one copy is changed, all the others must
   be changed in the same way to prevent inconsistencies and mistakes. While
   some attempts have been made to solve this problem, there is still a long
   way to go. When looking for document formats designed to server more general
   educational purposes, we find formats such as the Learning Material Markup
   Language (LMML) \citep{suss-1}, the Connexions Markup Language (CNXML) and
   the eLesson Markup Language (eLML) \citep{fisler-1}. All of these formats
   share their focus on the reuse of content, but all of them attempt this at a
   relatively high granularity level. Content can be organised in lessons or
   modules, and users are encouraged to use these, as a whole, in their
   teaching. When we investigated the formats more closely, we observed that
   outgoing links to external content were supported, but
   transclusion\footnote{The inclusion of content via references} was not. In
   relation to presentations, Microsoft's Slide Libraries exist as central
   repositories that store slides to enable slide sharing and reuse within an
   organisation. The dependency on SharePoint might represent a hurdle for some
   users, as not everyone has the ability and opportunity to set up such a
   server. A more significant issue is the fact that slides still need to be
   searched and manually copied into presentations. Keeping slides in the
   repository and in other presentations is the responsibility of the authors
   of those slides and those presentations, as no automatic update system is
   provided. SlideRocket and SlideShare are both similar tools showing
   intentions and providing functionality for content reuse. The SliDL
   \citep{canos-1} research framework works much like Microsoft's Slide
   Libraries, in that it allows for storage and tagging of slides in a database
   for reuse, but also in that it shares the same shortcomings. The ALOCOM
   \citep{verbert-1} framework aimed at flexible content reuse is built upon a
   content ontology and a (de)composition framework for legacy documents
   including \ppt documents, Wikipedia pages and SCORM content packages.
   However, ALOCOM may be too rigid for evolving presentation formats, and it
   currently only supports the authoring phase, although the tool does succeed
   in decomposing legacy documents as advertised.

   Aside from the similarities in the Web's and presentation environments'
   evolution, some of the problems mentioned in this section can find their
   solutions in the context of the Web. It should not come as a surprise then,
   that web technologies are being used more often recently in the realisation
   of presentation solutions. The Simple Standards-based Slide Show System
   (S5)\footnote{http://meyerweb.com/eric/tools/s5/} is an XHTML-based
   slideshow file format that enforces the standard slideware model. The W3C's
   Slidy \citep{raggett-1} initiative offers another presentation format based
   on the classical slideware model. Both of these formats have some valuable
   properties. They encourage a clean separation of content and visualisation
   through the use of CSS themes. The design is resolution independent, and the
   layout and font size adjust to the available screen real estate. Last but
   not least, some more recent HTML5-based presentation solutions such as
   impress.js, deck.js, Shower or reveal.js. Cross-device support is one of the
   most important advantages to leverage when using a well-known open standard
   such as HTML. However, as all of these solutions display some restrictions
   in terms of visualisation, navigation, and cross-media support, they are
   unfortunately too limited for our needs.

   The tools and projects discussed in this section mostly focus on
   distinguishing novel ideas for presentations. Nevertheless, the different
   concepts introduced in these tools do not offer interoperability between
   them. One project may focus on the authoring, another one fixates on novel
   content types and a third solution supplies radically new navigation
   mechanisms. Slideware tools may often allow third-party extensions but the
   API exposed to plug-in developers is usually limited by the software's
   underlying model. As an illustration, \ppt supports interaction from
   plug-ins with the presentation model, but the model dictates that a
   presentation consists of a sequence of slides. Many existing web-based
   presentation formats share this flaw. Because of this, we see a need for an
   open presentation platform such as \mxp to support innovation by
   contributing the necessary modularity and interoperability \citep{bush-1}.

   It is perhaps surprising that, to our knowledge, currently no tools exist to
   calculate dynamic layouts of content in slideware. Existing solutions
   include template systems, sometimes very fine-grained like \latex allowing
   you to define templates for every single layout choice, usually more coarse
   like \ppt* or Apple Keynote using Master Slides to define different layouts
   on a per-slide basis, and always with the option of letting the user
   customise the layout by hand, literally manually moving the content to the
   exact place where we want it, unhindered by style guides, good practices or
   common sense. This has resulted in mindboggling layout choices involving
   enormous amounts of tiny text crammed onto one slide, or pictures strewn
   across a slide overwhelming the audience with too much information at once.

  \section{Requirements for a new era of presentation tools}

   Here we propose a set of requirements to establish a wide range of
   presentation styles and visualisations. This set has been compiled based on
   a review of the more recent presentation solutions discussed in the previous
   section.

     \paragraph{Non-linear Navigation}
     
      As we mentioned before, traversing slides in a linear fashion is a
      remnant of the way early photographic slides worked. Over the years,
      people have grown used to this form of navigation despite the
      inconveniences. If the presenter unexpectedly needs to show anything
      other than the next or previous slide (e.g. to answer a question from the
      audience), they either need a considerable amount of time to scroll
      forwards or backwards, or they have to switch to the slide sorter view,
      to find the desired slide. Also troubling is the lack of any
      functionality allowing a single slide to be included multiple times
      throughout the presentation without duplicating the slide in question,
      meaning if any change has to be made to that slide the same change has to
      be performed on all copies. This poses the risk of overlooking some
      copies, introducing inconsistencies and facilitating mistakes. There are
      several manners in which this lack of flexible navigation might be
      addressed, including the possibility to define non-linear navigation
      paths \citep{spicer-1,edge-1} or zoomable user interfaces (ZUIs)
      \citep{good-1,lichtschlag-1,haller-1}.

     \paragraph{Separation of Content and Presentation}
     
      Similar to the approach of \latex and other professional typesetting
      systems, content should be written in a standardised way with
      visualisation being handled automatically by the typesetting system. The
      clear separation between content and presentation makes the presentation
      tool handle the visualisation, allowing the authors of a presentation to
      focus on the content. Additionally, this facilitates experimentation with
      different visualisations. \latex does have a document class called Beamer
      which was designed specifically for presentations, but while we were
      inspired by its structured and content-driven approach, the
      content-related functionality and the visualisation possibilities are too
      limited to be considered as a basis for an extensible presentation tool.

     \paragraph{Extensibility}
     
      Rapidly prototyping innovative navigation and visualisation techniques,
      but also new content types and presentation formats, should be easy in
      order for a presentation tool to be successful as an experimental
      platform for new presentation concepts. It should be possible to add or
      replace specific components without requiring changes in the core. A
      presentation tool should provide a modular architecture with loosely
      coupled components to be truly extensible. Note that this type of
      extensibility should be offered on the level of content types as well as
      for the visualisation engine and content structures.

     \paragraph{Cross-Media Content Reuse}
     
      We have previously briefly mentioned the lack of content reuse in
      existing presentation tools. Even though there is a wealth of open
      education material available, it is rather difficult to use this content
      in presentations. However, the concept of transclusion does work well for
      digital documents and parts of the Web (e.g. via the HTML img tag). The
      seamless integration of external cross-media content as implemented in
      these environments should also be supported by any modern presentation
      tool. This includes several different mechanisms that enable including
      parts of other presentations (e.g. slides), transcluding content from
      third-party document formats, and including content from open learning
      repositories.

     \paragraph{Connectivity}

      Connectivity for multi-device input and output has become more relevant
      in relation to presentation tools with the rise of social and mobile
      technologies. Multi-directional connectivity needs to be supported for
      several reasons. First, it is a requirement to enable the previously
      mentioned cross-media transclusion from external resources. Second,
      multi-directional connectivity is the basis of audience feedback via
      real-time response or voting systems \citep{dufresne-1} as well as other
      forms of multi-device interfaces.

     \paragraph{Interactivity}

      As mentioned earlier, content can be more interactive and the
      extensibility requirement addresses this issue since the intended
      architecture should support dynamic or interactive content and
      visualisations. However, traditional human input devices might not
      suffice for components offering a high level of interaction. As such, a
      presentation tool should facilitate the integration of other forms of
      input like gesture-based interaction using Microsoft's Kinect controller
      or digital pen interaction \citep{signer-2} as implemented by the
      PaperPoint \citep{signer-1} presentation tool.

     \paragraph{Post-Presentation Phase}

      Slide decks often play an important role as study or reference material,
      even if that was never their original goal. It is a trivial act to share
      traditional slide decks after a presentation, but this changes when the
      previously mentioned requirements are taken into account. The nonlinear
      navigation allows presenters to go through their content in a non-obvious
      order, and input from the audience might drive parts of a presentation,
      amongst other possible variables. Special attention should therefore be
      paid to the post-presentation phase. Playing back a presentation using
      the original navigational path, annotations and audience input should be
      made easy, while the content should also be made discoverable and
      reusable. With the rise and popularity of modern social media, there is a
      definite possibility to include the social aspect in a post-presentation
      phase through a content discussion mechanism.

  \section{\mxp Platform}
   \label{mxp-platform}

   This section presents the global architecture of the
   \mxp\footnote{http://mindxpres.com} crossmedia presentation platform as
   outlined in \figref{roels-1-fig-1}, which addresses the requirements
   presented in the previous section.

   \fig{roels-1-fig-1}{\mxp architecture}

   \subsection{Document Format and Authoring Language}

    A dedicated \mxp document format is used to store, structure and and
    reference content. Content is stored, structured and referenced in Each
    individual \mxp document contains the presentation's content itself and may
    also refer to some external content to be included. A new \mxp document can
    be constructed by hand similar to how \latex is authored, or --- in the
    near future --- it may be generated via a graphical authoring tool.
    Contrary to other presentation formats such as Slidy, S5 or OOXML, the \mxp
    authoring language abandons unnecessary HTML and XML specifics and focuses
    on a semantically more meaningful vocabulary. The syntax of the authoring
    language is almost entirely defined by plug-ins that enable the inclusion
    and visualisation of various media types and structures. To allow users
    some freedom in the way they present their information, the core \mxp
    presentation engine does little more than providing a runtime environment
    for plug-ins and lets them define the media types (e.g. video or source
    code) as well as structures (e.g. slides or graph-based content layouts).

    This also becomes apparent in the document format as every plug-in extends the
    available syntax. Any visual styling including different fonts,
    colours or backgrounds is achieved by applying specific themes to the
    underlying content.

   \subsection{Compiler}

    The compiler generates a self-contained portable \mxp presentation bundle
    based on a \mxp document. Although a \mxp document could be directly
    interpreted at visualisation time, we decided to create this intermediary
    step for a number of reasons. First, the compiler enables the creation of
    different types of presentations from the same \mxp document instance.
    This lets us not only create dynamic and interactive presentations but also
    more static output formats such as PDF documents for printing. Second, it
    is unwise to assume that there will always be an Internet connection
    available when giving a presentation. To overcome this possible issue, the
    compiler might create an offline version of a presentation with all
    necessary content pre-downloaded and included in the \mxp presentation
    bundle. Last but not least, the compiler might resolve incompatibility
    issues by, for instance, converting unsupported video formats or including
    certain HTML5 libraries.

   \subsection{\mxp Presentation Bundle}

    The dynamic \mxp presentation bundle contains the compiled content along
    with a portable cross-platform presentation runtime engine which enables
    more interactive and networked presentations. Resembling the original
    document, the compiled presentation content still consists of integrated
    content as well as references to external resources, such as online content
    that will be retrieved when the presentation is visualised. However, it
    should be noted that the content might have been modified by the compiler
    and, for example, been converted or extracted from other document formats
    that the runtime engine cannot process. References to external content may
    have been dereferenced by the compiler for offline viewing.

    A presentation bundle's core runtime engine consists of the three modules
    shown in \figref{roels-1-fig-1}. The \emph{content engine} is responsible
    for processing the content and linking it to the corresponding
    visualisation plug-ins. The \emph{graphics engine} provides all
    rendering-related functionality. For instance, some presenters may prefer a
    zoomable user interface because it provides a better overview of their
    content \citep{reuss-1}. This graphical functionality is also available to
    the plug-ins, which can make use of the provided abstractions. The
    \emph{communication engine} exposes a communication API which can also be
    used by plug-ins. It implements some basic functionality for fetching
    external content while also offering the possibility to form networks
    between multiple \mxp presentation instances as well as to connect to
    third-party hardware such as digital pens or clicker systems.

    Finally, the presentation bundle also contains a collection of
    \emph{themes} and \emph{plug-ins} as referenced by the presentation
    content. Themes may define visual styling on a global as well as on a
    plug-in level. The content engine encounters different content types and
    hands them over to the matching plug-in, which in turn uses the graphics
    engine to visualise the content.

   \subsection{Plug-in Types}

    \fig{roels-1-fig-2}{Structure plug-in examples}

    In order to attain the required flexibility, all non-core modules have been
    implemented as plug-ins. Even the most basic content types including text,
    images and bullet lists are handled through plug-ins. We distinguish
    between three major categories of plug-ins:

    \begin{itemize}

     \item \emph{Components} are the smallest elements of a presentation. The
     component plug-ins handle the visualisation for specific content types
     such as text, images, bullet lists, graphs or videos. The content engine
     invokes the corresponding plug-ins in order to visualise the content.

     \item \emph{Containers} are used to group and organise components in a
     specific way. One example of such a container is a slide, where each slide
     contains different content but also some recurring elements. For instance,
     every slide of a presentation can contain certain elements such as a
     title, a slide number and the author's name, all of which can be
     abstracted at a higher level. Another example is an image container that
     visualises its content as a horizontally scrollable list of images. It is
     important to observe that \mxp does not restrict us to the slide format
     and content can be laid out in many alternative ways.

     \item \emph{Structures} are high-level structures and layouts for
     components and containers. They may scatter content in a graph-like
     structure or they may clearly group it in sections like in a book. These
     are radically different ways of visualising and navigating content but the
     plug-in abstraction allows the user to easily switch between different
     presentation styles like the ones shown in \figref{roels-1-fig-2}.
     Structures differ from containers in that they do not restrict media types
     of their child elements in any way while they may influence the default
     navigational path through the content.

    \end{itemize}

   \subsection{Implementation}

    HTML5 and its related web technologies were chosen as the backbone for the
    \mxp presentation platform. Alternatives such as JavaFX, Flash or game
    engines were investigated as well, but HTML5 appeared to be the best
    option. The widely accepted HTML5 standard makes \mxp presentations highly
    portable, as any device with a recent web browser can display them,
    including smartphones and tablets. Moreover, HTML5 offers rich
    visualisation functionality by design and the inclusion of Cascading Style
    Sheets (CSS) and third-party JavaScript libraries makes it a powerful
    visualisation platform.

    \subsubsection{Document Format and Authoring Language}

     The \mxp document format that enables the simple expression of a
     presentation's content, structure and references is based on the
     eXtensible Markup Language (XML). \lstref{xml-1} shows a simple example
     of a presentation defined in our XML-based authoring language. The set of
     valid tags and their structure, apart from the \code{presentation} root
     tag, consists of what is provided by the available plug-ins.

     \begin{figure}[h!]
      \begin{lstxml}{xml-1}{Authoring a simple \mxp presentation}
<presentation>
  <slide title="Vannevar Bush">
    <bulletlist>
      <item>March 11, 1890 - June 28, 1974</item>
      <item>American Engineer, founder of Raytheon</item>
    </bulletlist>
    <image source="bush.jpg"/>
  </slide>
</presentation>
      \end{lstxml}
     \end{figure}

    \subsubsection{Compiler}

     The compiler has been implemented as a Node.js application. Not only does
     this accomodate the use of the compiler via a web interface or as a web
     service, but projects such as node-webkit also enable the compiler to be
     executed as a local offline desktop application. The decision to use
     server-side JavaScript was influenced by the fact that Node.js has the
     ability to bridge web and desktop technologies. On one hand, the framework
     facilitates interaction with other web services and allows us to work with
     HTML, JSON, XML and JavaScript visualisation libraries during compilation.
     On the other hand, the framework can carry out tasks for which web
     technologies are usually not suitable, including video conversion, legacy
     document format access, file system access or TCP/IP connectivity.

     To enable validation of a \mxp document in the XML format described above,
     an XML Schema exists which is augmented with additional constraints
     provided by the plug-ins. After validating the document, it is parsed and
     any discovered tags might trigger preprocessor actions defined by the
     plug-ins, such as the extraction of data from referenced legacy document
     formats (e.g. \ppt or Excel) or the conversion of an unsupported video
     format. Each tag is then converted to HTML5 and all information is encoded
     in the attributes of a \code{div} element. The HTML5 standard allows
     custom attributes that start with a \code{data-} prefix. \lstref{xml-2}
     hilights converted parts of the original XML document we saw in
     \lstref{xml-1}. Observe that no visualisation-specific information is
     included in the transformation, which merely results in a valid HTML5
     document ready to bundle into a self-contained package together with the
     presentation engine.

     \begin{figure}[h!]
      \begin{lstxml}{xml-2}{Transformed HTML5 presentation content}
<div data-type="presentation">
  <div data-type="slide" data-title="Vannevar Bush">
    <div data-type="bulletlist">
      ...
      \end{lstxml}
     \end{figure}

    \subsubsection{Presentation Engine}

     The presentation engine's main purpose is to create a visually appealing
     and interactive presentation based on the compiled HTML content. As
     \figref{roels-1-fig-1} shows, the presentation engine consists of several
     smaller components which enable plug-ins to implement powerful features
     with minimal effort. The combination of these components allows for rapid
     prototyping and evaluation of innovative visualisation ideas. A resulting
     \mxp presentation combining various structure, container and component
     plug-ins is shown in \figref{roels-1-fig-3}.

     \fig{roels-1-fig-3}{A \mxp presentation}

     \paragraph{Content Engine}
     
      The content engine is the first component that is activated when a
      presentation is loaded. It uses the well-known jQuery JavaScript library
      to process the content of the HTML presentation. Whenever a \code{div}
      element is discovered, the \code{data-type} attribute is read and the
      corresponding plug-ins are triggered in order to visualise the content.

     \paragraph{Graphics Engine}
     
      The graphics engine accomodates interesting new visualisation and
      navigation styles. Apart from some basic helper functions, it provides
      efficient panning, scaling and rotation via CSS3 transformations and
      supports zoomable user interfaces as well as the more traditional
      navigation approaches.

     \paragraph{Communication Engine}
     
      The communication engine offers abstractions that enable plug-ins to
      retrieve external content at runtime. It also provides the architectural
      foundation to form networks between different \mxp instances and to
      integrate third-party hardware \citep{roels-2}. For the \mxp prototype, a
      small Intel Next Unit of Computing Kit (NUC) was used with high-end WiFi
      and Bluetooth modules to act as a central access point and provide the
      underlying network support. \mxp presentation instances use WebSockets to
      communicate with other \mxp instances via the access point. The access
      point also acts as a container for data adapters that translate input
      from third-party devices into a generic representation that can be used
      by the \mxp instances in the network. In order to transcend simple
      broadcast-based communication, a routing mechanism was implemented based
      on the publish-subscribe pattern, allowing plug-ins to subscribe to
      specific events or publish information. The communication engine supplies
      the foundation for audience response systems \citep{roels-2} or even full
      classroom communication systems where the creativity of plug-in
      developers is the only limit.

     \paragraph{Plug-ins}
     
      Plug-ins are implemented as JavaScript bundles consisting of a folder
      containing JavaScript files and other resources such as CSS files, images
      or other JavaScript libraries. As a first convention, a plug-in should
      contain a manifest file with a predefined name. The manifest describes
      the plug-in using metadata, such as the plug-in name and version, as well
      as a list of tags it provides and handles to be used in a presentation.
      The plug-in claims unique ownership for these tags and is solely
      responsible for their visualisation if the content engine encounters
      them. As a second convention, a plug-in must implement at least one
      JavaScript object providing certain methods, one of them being the
      \code{init()} method which is called when the plug-in is loaded by the
      presentation engine. The plug-in may decide to load additional JavaScript
      or CSS via the provided dependency injection functionality. A second
      method it needs to implement is the \code{process()} method which is
      invoked with a pointer to the corresponding DOM node as a parameter by
      the content engine when it encounters a corresponding tag. A plug-in is
      free to modify the DOM tree and may also register callbacks to enable
      future interaction with the content.

     \paragraph{Themes}
     
      CSS is currently the driving technology behind a basic templating system.
      These themes offer styling either on a global or on a plug-in level. It
      has always been the intention to replace this system with a more advanced
      layout engine that steers away from templates, and part of that is
      incidentally one of the goals of this thesis. The intention is to provide
      layout functionality far beyond what can be attained using templates.
      However, the styling functionality will still be handled by the current
      system. In the future this system may still be replaced or enhanced to
      allow more dynamic styling using JavaScript.

   \subsection{Use Cases}

    To prove the merits of the architectural and technological choices, we
    demonstrate the extensibility and feasibility of \mxp as a rapid
    prototyping platform through demonstration of a number of content- and
    navigation-specific plug-ins that have been developed so far. Additional
    plug-ins for audience-driven functionality such as real-time polls, screen
    mirroring and navigational takeover can be found in \citep{roels-2}.

    \subsubsection{Structured Overview Plug-in}

     In Section \ref{mxp-platform} we described how structure plug-ins may
     alter and influence the way presentations are visualised and navigated. In
     order to illustrate this, a structure plug-in called \emph{structured
     layout} was implemented, to combine a zoomable user interface with the
     ability to group content into sections. The resulting visualisation of the
     \emph{structured layout} plug-in is displayed in \figref{roels-1-fig-3}.
     Whenever a new section is reached while navigating through the
     presentation, the view is zoomed out to provide an overview of the content
     within the section and to convey a sense of progress.

    \subsubsection{Slide Plug-in}

     Even though one of the main intentions of \mxp is to discard the concept
     of slides with all their limitations, it was deemed necessary to include
     support for this concept as well. As such, a slide-like container plug-in
     was created. While the benefits and issues of using slides with a fixed
     size are debatable, this plug-in was implemented as a testament to the
     framework's versatility. The main purpose of the slide plug-in is to
     produce a rectangular styleable component container with an optional title
     and some other information. Containers may also contribute functionality
     to layout their content. In this instance, the slide plug-in implements a
     quick and easy layout mechanism that allows the presenter to partition the
     slide into rows and columns. Slide containers are then assigned to these
     slots in the order that they are discovered. The use of the slide plug-in
     together with the resulting visualisation is depicted in
     \lstref{roels-1-fig-4}. This demonstrates the use of the image plug-in (a
     component plug-in) as well, which introduces a simple form of cross-media
     transclusion. A visualised external image can be cropped and filters (e.g.
     colour correction) may be applied without duplicating or modifying the
     original source.

     \begin{figure}[h!]
      \begin{subfigure}{0.53\textwidth}
       \vspace{-1em}
       \begin{lstxml*}
<slide layout="\60\40" title="Vannevar Bush">
 <bulletlist>
  <item>About
   <item>March 11, 1890 - June 28, 1974</item>
   <item>American Engineer</item>
   <item>Founder of Raytheon</item>
  </item>
  <item>...
  </item>
 </bulletlist>
 <image source="http://example.com/bush.jpg">
  <crop bounds="10%, 5%, -10%, -20%" />
 </image>
</slide>
       \end{lstxml*}
      \end{subfigure}
      \hfill
      \begin{subfigure}{0.43\textwidth}
       \fignl{roels-1-fig-4}
      \end{subfigure}
      \renewcommand{\figurename}{Listing}
      \renewcommand{\figureshortname}{Lst.}
      \cl{roels-1-fig-4}{Slide plug-in}
     \end{figure}

    \subsubsection{Enhanced Video Plug-in}

     When showing a video in an educational setting, we often need more
     functionality than the average video player can provide
     \citep{reuss-1}. \mxp offers an enhanced video plug-in as demonstrated in
     \lstref{roels-1-fig-5}, adding the possibility to overlay a video with text
     or arbitrary shapes. This overlay functionality can be used as a basic
     captioning system as well as to highlight items of interest during
     playback.

     Furthermore, there is an option to trigger certain events at specified
     times. One may mark certain points where a video should automatically
     pause at, highlighting an object and then continuing playback after a
     specified amount of time. Other features include the bookmarking of
     certain positions in a video for direct access and the possibility to
     display multiple videos in a synchronised manner. The enhanced video
     plug-in leverages the default HTML5 video player and overlays it with a
     transparent \code{div} element for augmentation. Currently it utilizes the
     HTML5 video API to synchronise the creation and removal of overlays but a
     SMIL-based implementation might be used in the future.

     \begin{figure}[h!]
      \begin{subfigure}{0.53\textwidth}
       \vspace{-1em}
       \begin{lstxml*}
<video source="vid.mp4">
 <caption start="0:00" duration="1500ms">
  Lecture 3 - Butterfly Species
 </caption>
 <pause start="0:43" duration="5s">
  <caption>
   The peacock butterfly (aglais io) ...
  </caption>
  <highlight x="30%" y="9%"
             width="35%" height="40%" />
 </pause>
</video>
       \end{lstxml*}
      \end{subfigure}
      \hfill
      \begin{subfigure}{0.43\textwidth}
       \fignl{roels-1-fig-5}
      \end{subfigure}
      \renewcommand{\figurename}{Listing}
      \renewcommand{\figureshortname}{Lst.}
      \cl{roels-1-fig-5}{Enhanced video plug-in}
     \end{figure}

 \newpage

    \subsubsection{Source Code Visualisation Plug-in}

     We have previously mentioned the issues involved with visualising complex
     resources such as source code. Our \mxp source code plug-in exports a
     \code{code} tag allowing the presenter to paste their code into a
     presentation and have \mxp visualise it nicely through syntax highlighting
     using the
     SyntaxHighlighter\footnote{http://alexgorbatchev.com/SyntaxHighlighter/}
     JavaScript library. Whenever the content engine encounters a \code{code}
     tag, this plug-in is invoked to beautify the code. It also automatically
     adds vertical scrollbars for larger segments of source code as illustrated
     in \lstref{roels-1-fig-6}.

     \begin{figure}[h!]
      \begin{subfigure}{0.53\textwidth}
       \vspace{-1em}
       \begin{lstxml*}
<code>
 <publications>
  <publication type="inproceedings">
   <title>An Architecture for Open Cross-Media
          Annotation Services</title>
   <author>
     <surname>Signer</surname>
     <forename>Beat</forename>
   </author>
   <author>
     <surname>Norrie</surname>
     <forename>Moira</forename>
   ...
</code>
       \end{lstxml*}
      \end{subfigure}
      \hfill
      \begin{subfigure}{0.43\textwidth}
       \fignl{roels-1-fig-6}
      \end{subfigure}
      \renewcommand{\figurename}{Listing}
      \renewcommand{\figureshortname}{Lst.}
      \cl{roels-1-fig-6}{Source code visualisation}
     \end{figure}

   \subsection{Discussion and Future Work}

    \mxp currently supports transclusion and cross-media content reuse through
    the use of plug-ins. For example, the image or video plug-in can visualise
    (and enhance) external resources, a dictionary plug-in could retrieve
    definitions on demand via a web service or we might create a plug-in that
    lets us import content (e.g. \ppt slides) from legacy documents at compile
    time. Nevertheless, the introduction of generic reuse tags in our document
    format is actively being investigated. This would allow the presenter to
    transclude arbitrary parts of other \mxp presentations. While the focus has
    been on the cross-media aspect of resources that can be used in a
    presentation, the cross-media publishing aspect might also be considered in
    the future via alternative compiler output formats.

    The creators of \mxp are aware that the current authoring of \mxp
    presentations faces some usability difficulties. The average presenter
    cannot be expected to construct an XML document or any CSS themes. In order
    to address this issue and further evaluate \mxp in real-life settings, a
    graphical \mxp authoring tool is currently being developed. They further
    intend to provide a central plug-in repository which would enable novice
    users to find, install and use new plug-ins via the authoring tool in a
    simple manner. In the long run, the use of monolithic documents is to be
    revised and a move towards repositories of semantically linked information
    based on the RSL hypermedia metamodel will be executed \citep{signer-3}.
    This will promote content reuse and sharing, while also creating
    opportunities for context-aware as well as semi-automated presentation
    authoring where relevant content is suggested by the authoring tool.

  \section{Layout}

   Proper layout is incredibly important when trying to transfer knowledge and
   information through written and visual media. Layout can help clarify
   boundaries and relations between pieces of information, by grouping and
   separating them appropriately. Layout is one component of a presentation's
   design, that --- combined with other decisions --- determines the number and
   nature of the visual representations of the information the creator wants to
   communicate, along with its format\footnote{The way the visual objects are
   realised (e.g. as text, graphics, UI widgets\ldots), and their attributes
   (e.g. color, texture, font\ldots)}. The layout of a presentation can have a
   tremenduous influence on its effectiveness in communicating information to,
   and obtaining information from, the audience it is meant to interact with.
   The importance of individual objects can be emphasised or minimised, and the
   connection between objects can be clarified or blurred. A well laid out
   presentation can provide a narrative for the viewer to discover, inferring
   correct links between the objects along the way, and to accomplish tasks
   quickly and correctly, increasing the presentation's effectiveness.

   Creating a good layout is almost never easy. People often spend more time on
   the layout of their presentation than the content. Most, if not all,
   decisions in layout are made by human beings. Some of them are professional
   designers who spend years learning and figuring out how to create effective
   layouts, and even then they may take hours or days to create even a single
   screen of a presentation. In fact, the more someone knows about proper
   layout and design, the more time they may spend perfectioning their work.
   However, sometimes time-critical information must be communicated and the
   layout process is too expensive and too slow to address these situations.
   This can be a serious problem (see also section \ref{nasa}). Many software
   packages have been developed to make this process easier, to get better
   results, to give more or less control to the creators. Many different
   approaches have been taken, and yet most of them still involve having a
   human being make the final decisions on the layout.

   There are tools like \ppt, which give you some guidelines and some templates
   but generally let you do your own thing. If your own thing is entirely
   different from any best practices on layout, nothing will stop you. Other
   tools like \latex give you complete control over every aspect of the layout,
   while setting some sensible defaults so that you can get a good-looking
   layout without much effort, while still letting you do whatever you want
   once you overcome the steep learning curve that separates the casual users
   from the experts. There are tools that combine the power of \latex with the
   comfort of WYSIWYG editors, bringing the casuals a bit closer to the
   experts. But all of those tools have one thing in common: every aspect of
   every layout they create has, at some point, been designed and decided upon
   by a human being.

   Aesthetics are a natural phenomenon, and the creation of aesthetically
   pleasing layouts is therefore a manifestation of our instincts. As with most
   instincts, it has proven difficult to translate this into a concept that can
   be understood by a computer. Moreover, it is still difficult to explain it
   in human terms, which --- according to a popular quote often attributed to
   Albert Einstein --- proves we do not fully understand it ourselves.

   When we look to other technologies, we do find some automated layout
   implementations. For example, the web has had to adapt to mobile devices
   with small screens over the past few years, and has done this gracefully by
   creating the concept of responsive design. In short, this allows websites to
   adapt their layout to any screen, no matter the size. While this is often a
   hard-coded difference, where effectively two or more versions of the same
   webpage are created aimed at different screen sizes, some websites take a
   more dynamic approach based on constraints. As the space the page is to be
   displayed on gets smaller, the layout algorithm may decide to display
   content below other content instead of side-by-side, it may scale images to
   fit the screen, it may even switch fonts and font sizes if necessary.

   This constraint-based technique is described in a few papers
   \citep{lok-1,hurst-1}, but has --- to our knowledge --- not been applied in
   any presentation software so far. This is surprising, as presentations often
   look like they could use some of this magic. A proper constraint-based
   layout algorithm could allow any user to drop content onto a slide, without
   worrying about clarity or even legibility, and the algorithm could take care
   of the rest. Of course, there are some limits in traditional slideware that
   may hinder this approach: if a user decides to put more content on a slide
   than there is physical room available, the algorithm could either make the
   content smaller or split it across several slides, but either solution may
   bring its own problems up. An advantage of ZUIs is that no matter how small
   the content gets, we can still zoom in to make it clear again\footnote{It
   should be noted that \mxp in its current form does not support this level of
   zooming. While the software can zoom out to provide an overview of the
   presentation while zooming in on the separate components, it is not yet
   possible to zoom in or out extremely to reveal 'hidden' parts of the
   presentation. This is something we encourage to look into and change,
   because it can greatly improve both our layout solution as well as the whole
   \mxp experience in general.}.

   \subsection{Algorithms}
    \label{related-algorithms}

    When researching layout algorithms, one will often come across the very
    active field of graph layout \citep{battista-1}. We will not go into the
    specifics of this field, as most of the issues with which it is concerned
    are specific to problems caused by the explicit visual representation of
    graph edges --- for example, the minimisation of edge crossing
    \citep{battista-2, shahrokhi-1}. The same applies to automated layout as
    referring to automated circuit layout for VLSI chip fabrication
    \citep{hu-1, lengauer-1} as well as automated placement of pieces to be cut
    from a bolt of cloth used to produce clothing \citep{milenkovic-1}.
    Contrary to presentation layouts (including graph layouts), these layouts
    do not attempt to make themselves understandable to the human mind, but
    rather are designed to meet the requirements of a fabrication process.
    While some techniques used therein definitely apply to our more general
    problem of automated presentation layout (e.g. general constraint solvers)
    others decidedly do not (e.g. bin-packing techniques \citep{hofri-1} that
    result in minimal area layouts at the expense of maintaining visually
    obvious relationships between objects).

   \subsection{Simple techniques}
    \label{simple-techniques}

    Most modern user interfaces are built with a UI toolkit (e.g., Sun
    JFC/Swing \citep{sun-1}, Microsoft Foundation Classes \citep{microsoft-1},
    and their predecessors, such as Xtk \citep{mccormack-1} or Tk
    \citep{ousterhout-1}) which provide some basic functionality such as
    creating buttons and windows. Toolkits usually include layout managers to
    assist the user interface designer in deciding how objects should be places
    inside a managed container. Layout managers allow the programmer to add
    objects to a container and optionally specify additional constraints while
    forgoing the need to specify the absolute position and size of every
    object. As such, it becomes possible to create layouts that adapt to
    changes in the container’s size.

    A layout manager dictates the positions and sizes for the objects under its
    control at run time, guided by a set of constraints defined by a simple
    layout policy on which the manager was based and parameters specified by
    the programmer. Strict horizontal (row) or vertical (column) layout,
    row-major or column-major layout where objects are placed in the next row
    or column to prevent exceeding their container’s boundaries, border layout
    that lets objects reside in the north, south, east, west, or center of the
    container as specified by the programmer, and grid layout in which objects
    are placed in one position (or straddling multiple positions) in a 2D grid,
    are some typical layout policies. Programmer-specified parameters indicate
    preferred, minimum, and maximum widths and heights of objects; and spacing,
    both between objects and between objects and the container’s edges. 

    A layout may be designed as a hierarchy of managed containers, each with
    their specific layout policies, on which additional constraints can be
    placed through programmer-specified parameters. Thus, a layout manager
    does not actually design the layout. It actually only instantiates the
    layout at run time based on the structure and parameters specified by the
    programmer. Designing a simple layout (e.g., four pictures lined up in
    row-major order) is easy for most programmers, but complex hierarchical
    layouts, while possible, are much more tedious and difficult, especially if
    any robustness is desired when resized.

    Commercial presentation systems intended primarily for sequential
    presentations --- so-called \emph{slideware}, including \ppt, Keynote and
    OpenOffice Impress --- offer a set of preauthored style “templates” (and
    the ability to create new ones) that can be applied to existing material.
    Compared to the parameterized layouts of UI toolkit layout managers, most
    of these template-based systems are simpler. However, users of these
    systems often move floating objects around by hand to guide or overrule
    simplistic placement policies.

   \subsection{Constraint satisfaction}
    \label{constraint-satisfaction}

    The vast majority of research in automated layout to date heavily
    emphasises constraint-based methods
    \citep{vanderzanden-1,borning-1,graf-1,hudson-3,kochhar-1,hudson-2,weitzman-2,myers-2}.
    Describing layouts as a set of constraints is very intuitive. The goal of a
    constraint-based automated layout system is to take a constraint network
    defining relations between objects, and generate the positions and sizes
    for each of the objects in the network. Any constraint-based automated
    layout system can be characterized by the kinds of constraints it observes;
    their description and the manner in which they are obtained, and resolved;
    and the way the system deals with constraint inconsistencies, loops and
    other hazards that might prevent the solution from converging.

    \subsubsection{Types of constraints}

     \paragraph{Abstract constraints}

      Abstract constraints describe high-level relationships between the
      components that are part of the layout. Abstract constraints such as
      \code{EXT1 REFERENCES PIC1} and \code{TITLE IS IMPORTANT} are adequately
      high-level that content authors can easily specify them, and are
      remarkably effective when used in interactive systems since the author
      needs no additional technical or artistic skill to specify them.

      While it may seem like \code{TEXT1 REFERENCES PIC1} implies that
      \code{TEXT1} and \code{PIC1} should be relatively close to each other in
      the generated layout, abstract constraints by themselves do not specify
      the position and size of the components of a layout.
     
      The reason for this is that a translation component performs the mapping
      between abstract constraints and spatial constraints before spatial
      constraints are passed to the numeric constraint solver. The
      abstract–spatial constraint translator may decide to translate the
      abstract constraint \code{TEXT1 REFERENCES PIC1} into a combination of spatial
      constraints. The outcome of this operation could be that \code{PIC1} is placed
      right next to text \code{TEXT1}, or that \code{PIC1} is put on a different page with
      some visual cue to guide the audience to it from \code{TEXT1}.

     \paragraph{Spatial constraints}
      \label{spatialcon}

      The geometric structure of the presentation can be expressed directly
      using spatial constraints . For instance, we may wish for a certain block
      of text to be placed below another block of text that the user is
      required to read first. Another example of spatial constraints can be
      found in the intention to fit all objects into a space of a certain size.

      There exist several reasons to impose spatial constraints. One of the
      most common reasons is to enhance the visual quality and aesthetics of
      the presentation. Many primitive automated layout systems have been
      created based on computer science and mathematics alone \citep{beach-1}.
      These systems have a tendency to approach the issue as a purely
      theoretical question of tiling and use optimisation techniques to find a
      solution \citep{luders-1}. Such systems will frequently not consider
      simple legibility rules (e.g. text should not be packed onto the screen
      in blocks of random size but rather be placed into columns that runs down
      the entire page) and style guidelines (e.g. all captions should be
      placed beneath their associated figures and spacing between a figure and
      surrounding text block should be consistent across the document).
     
      The way the components are represented may pose some kind of limitation
      on what types of spatial constraints can be used. The ``Cousins
      Problem'' is one such issue which may arise if the data structure
      containing the components does not permit referencing one component’s
      children from another component’s child.

      Using concepts from graphic design to create legible and pleasing output
      seems like an obvious approach. Some tools restrict the presentation
      content to a grid system, comparable to the layout of newspapers
      \citep{muller-1,hurlburt-1}. A grid system divides every screen or page
      of the presentation into an array of upright rectangles. Each component
      must cover one or more complete rectangles. One challenge when applying
      grid systems is that a picture may be cropped, padded with a border or
      have its aspect ratio changed in order to fit into the grid. This is
      because uniform scaling of the object may not be sufficient to make the
      object occupy an integral number of grid rectangles; for example, a very
      wide picture scaled to fit the grid's column width could become a single
      line of pixels.

      Well-defined environments, like network diagrams or label placement, have
      automated layout systems that often employ spatial constraints
      exclusively \citep{kosak-1,christensen-1}. These systems are designed to
      resolve issues such as the proximity between components being placed, the
      distance between a label and its target, and the contingency of confusing
      the audience by placing multiple labels close enough to the same target
      that the audience can not tell which label actually belongs to that target.
      Abstract constraints may be employed when formatting labels (larger
      cities have bigger names), but are generally not used for layout
      directly.

      In some systems, the user may specify abstract data constraints
      separately from spatial constraints. This enables a logical single
      presentation to have many different ``skins'', making the step towards
      displaying a single presentation using different media a trivial one
      \citep{weitzman-2}. This is particularly useful when trying to maintain a
      separation between content and layout in interactive layout systems.
      Another way to leverage this concept is by making the spatial constraints
      native to the system, thus eliminating any requirement for human
      intervention. Feiner’s GRIDS is an example of a such system
      \citep{feiner-1}.

      The efficiency of the constraint solver can sometimes be increase by
      using spatial constraints. For example, we might place a constraint on
      all objects of a certain type permitting them to be resized in only one
      direction \citep{linton-1}.
     
    \subsubsection{Expressing constraints}

     Defining a formal grammar that describes how the constraints are expressed
     would appear to be a great idea at first sight. One advantage of this
     approach is the ability to leverage a rich body of existing research for
     manipulating and parsing constraints. A rich grammar might be very
     flexible and expressive and result in better layouts \citep{weitzman-1}.
     However, powerful and expressive grammars may not be easy to operate with.
     This often becomes obvious when using grammars or ontologies that are
     designed in an extremely general and all-encompassing philosophy.
     Additionally, such a system may require a very complex solver to process
     the information it holds. One can imagine how difficult it is to create a
     system that can describe all possible high-level relationships between a
     presentation's components, although Zhou et al.\ has investigated this path
     to use in automatic graphics generation \citep{zhou-1}.

    \subsubsection{Obtaining constraints}

     Establishing where to obtain the constraints is one of the most critical
     practical issues when designing a constraint-based automated layout
     system. Examined approaches range from fully automated to the computer
     making suggestions.

     Many automated layout systems gather abstract constraints from structured
     input data \citep{mackinlay-1,casner-1,borning-1,beach-1}. These systems
     convert tables of numeric data into presentations. All relationships
     required to generate the layout are provided by the structure of the data.
     Other multimedia layout systems have languages to explicitly stipulate the
     abstract constraints to describe relationships such as “author-of,”
     “description-of” and “precedes” between the components
     \citep{weitzman-2,graf-1}. As the information we create is increasingly
     being stored in more structured formats \citep{bray-1}, the assumption
     that input data is readily available in a structured form is becoming ever
     more valid.

     \paragraph{Interactive specification}

      Interactive constraint specification systems are very popular as well,
      even with the obvious limitation that they require user input. Some
      systems aim to permit graphically naive content authors to create
      professional quality layouts. Others are aimed at reducing the amount of
      time a graphic designer needs to spend on a layout.

      Systems that take interactive input often do so for spatial constraints
      \citep{singh-2,hudson-2,borning-1}. The reason for this is that creating
      graphical user interfaces that let the user interactively place or adjust
      objects on the screen is easy. While graphical user interfaces to specify
      abstract constraints have been devised, abstract constraints do not
      usually need adjustment. Roth’s SAGE system \citep{roth-1} enables a user
      to link visual elements to database records.

      There are some interactive systems that automatically generate the final
      result based on the high-level design of the document provided by the
      user \citep{kim-1}. This is an advantageous approach when trying to
      empower the content author to design layouts without the need for a
      ``layout expert''. Other systems exist that take the opposite approach,
      making the system produce an initial layout and letting the user refine
      it \citep{singh-1}. These systems are more convenient in situations where
      the goal is to save the amount of time a graphic designer would need to
      create the layout.

     \paragraph{Automated extraction}

      Fully automated constraint extraction is the least explored method of
      obtaining constraints. There has been some work on combining natural
      language techniques with automated layout \citep{roth-2}. This is
      especially interesting if natural language generation is being used to
      create the content. If the content generators are computer programs,
      having the generator send abstract constraints that describe
      relationships between components, as well as annotating the text with
      flags marking which parts are particularly important, becomes an obvious
      solution

      Another examined method tries to extract abstract constraints from the
      entity relationships found in SQL databases \citep{pizano-1}. In this
      approach abstract constraints are deduced from data structures originally
      intended for use elsewhere, unlike the natural language generation
      system that passes additional information to the layout system.

    \subsubsection{Constraint solvers}

     An automated layout system based on constraints must somehow be able to
     resolve the constraints presented to it. Formally, the problem posed here
     is a form of the constraint satisfaction problem (CSP)
     \citep{mackworth-2,mackworth-1}. Solving the problems in this field has
     been approached using both randomized and deterministic algorithms.
     Generally, constraint solvers can be categorized as applying either a
     local or a global methodology.

     \paragraph{Local techniques}

      Local constraint solvers take a bottom-up approach to the constraint
      satisfaction problem. This is comparable to inductive reasoning, meaning
      a small subset of the universe is first solved. Two paths exist to solve
      the rest of the constraints and generate the final presentation. The
      first entails solving many small subsets of the constraints independently
      and subsequently running a second resolution phase, combining the
      results. The second involves iteratively resolving constraints at the
      border between the constraints that have already been solved and those
      that have yet to be considered \citep{nilsson-1}.

      Local-resolution techniques can pose some issues if the solver encounters
      local minima \citep{borning-2}. By resolving small subsets first, the
      solver may make decisions that cause the system to reach a suboptimal
      final solution. The advantage, however, is that local-resolution
      techniques generally deliver results much faster than global techniques.

     \paragraph{Global techniques}

      Global constraint solvers approach the constraint satisfaction problem
      from the top down. Global techniques are not ordinarily affected by the
      problem of local minima, but they require more computation time. To
      counteract this issue, numeric solvers that use iterative approximation
      techniques have been employed \citep{kurlander-1}. Randomized computation
      techniques (e.g., genetic algorithms and simulated annealing) have also
      been utilized for label placement \citep{christensen-2}.

    \subsubsection{Inconsistency policies}

     The size of the set of constraints is proportional to the possibility that
     there will be some problems. Specifically, some constraints may contradict
     others and possibly make the set of constraints unsolvable. In order to
     generate a layout in such cases, a resolution policy must be specified.

     The simplest approach to resolving inconsistencies is to avoid them.
     Instead of bloating the system with inconsistency handling, the grammar
     used to specify the constraints is designed in such a way that cycles
     cannot occur \citep{weitzman-2}.

     Another popular method for dealing with inconsistency is to prioritize the
     constraints \citep{graf-1}. By assigning an inherent priority to each
     constraint, the system can intelligently decide which constraints to drop
     should a contradiction be encountered. Problem may still arise here if two
     conflicting constraints have the same priority. When this happens, the
     system can apply a tie-breaking strategy (e.g., first-come first-served or
     pick one randomly) \citep{nilsson-1}. Priorities are essential for
     generating effective layouts in systems with complex networks of both
     abstract and spatial constraints.

   \subsection{Learning techniques}
    \label{learning-techniques}

    Researchers have applied machine learning to many automated multimedia
    authoring systems. This includes speech synthesis \citep{pan-1} and natural
    language generation \citep{kamimura-1}, as well as to graph layout
    \citep{masui-1}. However, most automated layout systems do not leverage the
    large body of existing work by the AI community in machine learning. Those
    that do tend to use learning only during the interactive specification of
    constraints \citep{myers-1,borning-1}. They try to “learn” by interacting
    with the user. The Marquise system \citep{myers-1} lets a user set the
    system into a training mode that demonstrates the relative locations of
    components to the system. Spatial constraints are then extracted from this
    interaction with the user. If no constraints can be extracted, the system
    falls back to asking the user to specify the position explicitly. Borning’s
    \citep{borning-1} ThingLab adds the ability to demonstrate animation, but
    is otherwise similar to Myer's Marquise.

    The use
    of learning techniques
    was also explored recently through some work in automated graphics generation
    \citep{zhou-3}. Zhou categorizes the space of rules that
    need to be acquired to generate a presentation into three groups:
    information learning space, visual learning space and rule learning space.

    Visual learning space relates directly to spatial constraints, and thus
    is similar to Myer’s and Borning’s work. Contrary to Marquise and ThingLab
    however, Zhou’s system applies full-strength machine learning that can be
    fully automated by providing the system with a large dataset of
    presentations designed by a “layout expert” in addition to the interactive
    methods.

