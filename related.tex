% vim:ts=1:et:nospell:spelllang=en_gb:ft=tex

 \chapter{Related work}

  \emph{This chapter's content is largely based on ``MindXpres: An Extensible
  Content-driven Cross-Media Presentation Platform'' \citep{roels-1}.}

  \section{Background}

   The importance of digital presentations in this day and age cannot be
   understated. Millions of presentations are created every day, supporting the
   oral transfer of knowledge and playing an important role in educational
   settings. Their origins as tools for creating physical media such as
   photographic slides or transparencies for overhead projectors are still
   reflected in the underlying concepts and principles of slide-based
   presentation tools. The rectangular boundaries of a slide, and the linear
   navigation between slides, are still restrictions we face today in digital
   presentations. Tufte argues that these concepts of slideware have a negative
   impact on the effectiveness of knowledge transfer \citep{tufte-1}. While
   the presenter is compelled to squeeze complex ideas into a linear sequence
   of slides, those ideas are rarely sequential by nature, resulting in a loss
   of relations, overview and details. An initial approach to address these
   issues might involve creating minimalistic presentations or introducing some
   structure via a table of contents. Sadly, when complex knowledge or other
   pieces of rich information need to be presented “as is” \citep{farkas-1} ---
   as in the domain of learning --- this does not work.

   One of the main issues with traditional slideware presentations is their
   monolithic nature, especially when content is spread over many
   self-contained presentation files. ``Reusing'' previous work involves either
   switching between files while giving a presentation or duplicating some
   slides in the new presentation. It should be noted that this issue is not
   limited to the reuse of single slides: there is an ever increasing wealth of
   resources available for reuse, spread over a wide spectrum of distribution
   channels and formats. The possibility to include content by reference or
   transclusion \citep{nelson-1} may contribute in crossing the boundaries
   between different types of media and prove beneficial in the context of
   modern cross-media presentation tools.

   The difference in functionality between the authoring of content and its
   visualisation is striking as well. The primary editors consist of mostly
   toolbars and buttons used for selecting and specifying the way content
   should be visualised, while support for authoring the content itself is not
   quite as extensive. Modern slideware has grown to include basic multimedia
   types such as videos, but most content is still rather static. It is, for
   example, not possible during a presentation to easily switch from a bar
   chart to a pie chart data visualisation, or to dynamically change some
   values in the represented data and immediately see the effect in the graph,
   which could be beneficial for knowledge transfer \citep{holzinger-1}. The
   audience could also be more actively involved in the presentation, through
   audience response and classroom connectivity systems providing multi-device
   interfaces allowing to share knowledge and results during, as well as after,
   a presentation. The evolution of presentations is reminiscent of the Web2.0
   movements, where users have switched roles from purely consuming content to
   contributing as well, content has become more dynamic and interactive, and
   service-oriented architectures (``The Cloud'') have ensured decentralisation
   of content.

   In order to move a step towards the next generation of cross-media
   presentation tools, it is essential to allow the rapid prototyping and
   evaluation of new concepts for the representation, visualisation and
   interaction with content.

   Before discussing the requirements for a new generation of presentation
   tools, we briefly introduce existing slideware solutions. Afterwards, we
   describe the architecture of \mxp, its extensible nature and its plug-in
   mechanism. The HTML5-based implementation of \mxp is then discussed through
   demonstration of several use cases and \mxp plug-ins.

   A specific issue with slideware we'd like to focus on in this thesis, is the
   trouble with layout in presentations. It can be hard to display the content
   you want in a way that's clear, informative and nice to look at. The vast
   majority of layouts created today is mostly done by hand: a human graphic
   designer or ``layout expert'' makes most, if not all, of the decisions about
   the position and size of the objects to be presented \citep{lok-1}. Most
   software offers some templates, allowing you to drop pictures and text into
   predefined slots and places on a slide, but then those templates have been
   defined by someone else too. Computer-generated layout is rare and usually
   not quite up to the task.

   \mxp is among the software packages offering templates, in that layout is
   handled by whichever plug-in you choose, but so far no plug-ins have defined
   dynamic layout algorithms, rather sticking to predefined ways to put text
   and pictures on slides. But as \mxp does not constrain us to the limits of
   slides, this should be seen as an opportunity to offer dynamic layout as
   well. After all, if we're not limited to a certain area within which our
   content should fit, it should be much easier to put content next to each
   other in a way that makes sense.

  \section{Existing solutions}

   Since digital slideware was first introduced, their influence, advantages
   and disadvantages have been studied extensively. There have been studies
   acknowledging the benefits of slideware as a teaching asset
   \citep{holzinger-1}, while others have been less positive. Tufte
   \citeyearpar{tufte-1} heavily criticises slideware for its infatuation with
   outdated concepts. He discusses the many ramifications of dimensional and
   structural limitations as well as linear navigation, and points out the
   discrepancy with how the human mind works. Amongst Tufte's conclusions, and
   also confirmed by Adams \citep{adams-1}, is the suggestion that slide-based
   presentations are not appropriate for every kind of knowledge transfer and
   especially not in a scientific context. Recent work shows the importance
   towards the learning process of integrating content into the bigger picture,
   both structurally and visually \citep{gross-1}, which is affected by the
   navigation and visualisation.

   Several approaches have been proposed to offer non-linear navigation.
   CounterPoint \citep{good-1}, Fly \citep{lichtschlag-1} and Prezi, provide
   Zoomable User Interfaces (ZUIs) which offer virtually unlimited space.
   Microsoft has experimented with this concept as well in pptPlex. Other
   approaches to escape the confines of the slide have been noticed, like
   MultiPresenter \citep{lanir-1} or tiling slideshows \citep{chen-1}.
   PaperPoint \citep{signer-1} and Palette \citep{nelson-2} additionally
   facilitate the non-linear navigation of digital presentations consisting of
   slide selection through augmented paper-based interfaces. Lastly, a category
   of authoring tools exists which use hypermedia to implement varying paths
   through a set of slides. NextSlidePlease \citep{spicer-1} enables users to
   define a weighted graph of slides, and tries to suggest navigational paths
   based on the link weights and the remaining presentation time. Microsoft
   cultivates this idea in their HyperSlides \citep{edge-1} project. Garcia
   \citep{garcia-1} has additionally explored the potential of \ppt* as an
   authoring tool for hypermedia-based presentations.

   \ppt* was officially released in 1990, with Windows 3.0 \citep{austin-1}. It
   had originally been developed as Presenter, but trademark issues caused a
   name change early on. It was also originally build for the Macintosh, which
   may seem surprising nowadays but was actually common practice back then
   since the Macintosh was widely regarded as a better development environment,
   more mature, more stable and capable of far better performance and
   visualisations. Some may argue this still rings true today.

   Since then, it has grown to be the world's most popular slide show
   presentation program, alledgedly having been installed on over 1 billion
   computers worldwide, and being used on average 350 times \emph{per second}
   \citep{parks-1}. In 2012, it had a market share of 95\%, leaving the other
   5\% to be shared by alternatives such as Apple's Keynote, Prezi, SlideRocket
   and others. While this number is declining, it may not be going as fast as
   many people think. As most readers of this thesis have heard before, over 30
   million \ppt presentations are created every day, for all kinds of purposes,
   with good and bad results both presentation-wise and goal-wise.

   To reuse content in existing presentation tools, that content needs to be
   duplicated, which results in a multitude of redundant copies that need to be
   kept consistent with each other: if one copy is changed, all the others must
   be changed in the same way to prevent inconsistencies and mistakes. While
   some attempts have been made to solve this problem, there is still a long
   way to go. When looking for document formats designed to server more general
   educational purposes, we find formats such as the Learning Material Markup
   Language (LMML) \citep{suss-1}, the Connexions Markup Language (CNXML) and
   the eLesson Markup Language (eLML) \citep{fisler-1}. All of these formats
   share their focus on the reuse of content, but all of them attempt this at a
   relatively high granularity level. Content can be organised in lessons or
   modules, and users are encouraged to use these, as a whole, in their
   teaching. When we investigated the formats more closely, we observed that
   outgoing links to external content were supported, but
   transclusion\footnote{The inclusion of content via references} was not. In
   relation to presentations, Microsoft's Slide Libraries exist as central
   repositories that store slides to enable slide sharing and reuse within an
   organisation. The dependency on SharePoint might represent a hurdle for some
   users, as not everyone has the ability and opportunity to set up such a
   server. A more significant issue is the fact that slides still need to be
   searched and manually copied into presentations. Keeping slides in the
   repository and in other presentations is the responsibility of the authors
   of those slides and those presentations, as no automatic update system is
   provided. SlideRocket and SlideShare are both similar tools showing
   intentions and providing functionality for content reuse. The SliDL
   \citep{canos-1} research framework works much like Microsoft's Slide
   Libraries, in that it allows for storage and tagging of slides in a database
   for reuse, but also in that it shares the same shortcomings. The ALOCOM
   \citep{verbert-1} framework aimed at flexible content reuse is built upon a
   content ontology and a (de)composition framework for legacy documents
   including \ppt documents, Wikipedia pages and SCORM content packages.
   However, ALOCOM may be too rigid for evolving presentation formats, and it
   currently only supports the authoring phase, although the tool does succeed
   in decomposing legacy documents as advertised.

   Aside from the similarities in the Web's and presentation environments'
   evolution, some of the problems mentioned in this section can find their
   solutions in the context of the Web. It should not come as a surprise then,
   that web technologies are being used more often recently in the realisation
   of presentation solutions. The Simple Standards-based Slide Show System
   (S5)\footnote{http://meyerweb.com/eric/tools/s5/} is an XHTML-based
   slideshow file format that enforces the standard slideware model. The W3C's
   Slidy \citep{raggett-1} initiative offers another presentation format based
   on the classical slideware model. Both of these formats have some valuable
   properties. They encourage a clean separation of content and visualisation
   through the use of CSS themes. The design is resolution independent, and the
   layout and font size adjust to the available screen real estate. Last but
   not least, some more recent HTML5-based presentation solutions such as
   impress.js, deck.js, Shower or reveal.js. Cross-device support is one of the
   most important advantages to leverage when using a well-known open standard
   such as HTML. However, as all of these solutions display some restrictions
   in terms of visualisation, navigation, and cross-media support, they are
   unfortunately too limited for our needs.

   The tools and projects discussed in this section mostly focus on
   distinguishing novel ideas for presentations. Nevertheless, the different
   concepts introduced in these tools don't offer interoperability between
   them. One project may focus on the authoring, another one fixates on novel
   content types and a third solution supplies radically new navigation
   mechanisms. Slideware tools may often allow third-party extensions but the
   API exposed to plug-in developers is usually limited by the software's
   underlying model. As an illustration, \ppt supports interaction from
   plug-ins with the presentation model, but the model dictates that a
   presentation consists of a sequence of slides. Many existing web-based
   presentation formats share this flaw. Because of this, we see a need for an
   open presentation platform such as \mxp to support innovation by
   contributing the necessary modularity and interoperability \citep{bush-1}.

   It is perhaps surprising that, to our knowledge, currently no tools exist to
   calculate dynamic layouts of content in slideware. Existing solutions
   include template systems, sometimes very fine-grained like \latex allowing
   you to define templates for every single layout choice, usually more coarse
   like \ppt* or Apple Keynote using Master Slides to define different layouts
   on a per-slide basis, and always with the option of letting the user
   customise the layout by hand, literally manually moving the content to the
   exact place where we want it, unhindered by style guides, good practices or
   common sense. This has resulted in mindboggling layout choices involving
   enormous amounts of tiny text crammed onto one slide, or pictures strewn
   across a slide overwhelming the audience with too much information at once.

  \section{New solutions}

   Here we propose a set of requirements to establish a wide range of
   presentation styles and visualisations. This set has been compiled based on
   a review of the more recent presentation solutions discussed in the previous
   section.

     \paragraph{Non-linear Navigation} As we mentioned before, traversing
      slides in a linear fashion is a remnant of the way early photographic
      slides worked. Over the years, people have grown used to this form of
      navigation despite the inconveniences. If the presenter unexpectedly
      needs to show anything other than the next or previous slide (e.g. to
      answer a question from the audience), they either need a considerable
      amount of time to scroll forwards or backwards, or they have to switch to
      the slide sorter view, to find the desired slide. Also troubling is the
      lack of any functionality allowing a single slide to be included multiple
      times throughout the presentation without duplicating the slide in
      question, meaning if any change has to be made to that slide the same
      change has to be performed on all copies. This poses the risk of
      overlooking some copies, introducing inconsistencies and facilitating
      mistakes. There are several manners in which this lack of flexible
      navigation might be addressed, including the possibility to define
      non-linear navigation paths \citep{spicer-1,edge-1} or zoomable user
      interfaces (ZUIs) \citep{good-1,lichtschlag-1,haller-1}.

     \paragraph{Separation of Content and Presentation} Similar to the approach
      of \latex and other professional typesetting systems, content should be
      written in a standardised way with visualisation being handled
      automatically by the typesetting system. The clear separation between
      content and presentation makes the presentation tool handle the
      visualisation, allowing the authors of a presentation to focus on the
      content. Additionally, this facilitates experimentation with different
      visualisations. \latex does have a document class called Beamer which was
      designed specifically for presentations, but while we were inspired by
      its structured and content-driven approach, the content-related
      functionality and the visualisation possibilities are too limited to be
      considered as a basis for an extensible presentation tool.

     \paragraph{Extensibility} Rapidly prototyping innovative navigation and
      visualisation techniques, but also new content types and presentation
      formats, should be easy in order for a presentation tool to be successful
      as an experimental platform for new presentation concepts. It should be
      possible to add or replace specific components without requiring changes
      in the core. A presentation tool should provide a modular architecture
      with loosely coupled components to be truly extensible. Note that this
      type of extensibility should be offered on the level of content types as
      well as for the visualisation engine and content structures.

     \paragraph{Cross-Media Content Reuse} We have previously briefly mentioned
      the lack of content reuse in existing presentation tools. Even though
      there is a wealth of open education material available, it is rather
      difficult to use this content in presentations. However, the concept of
      transclusion does work well for digital documents and parts of the Web
      (e.g. via the HTML img tag). The seamless integration of external
      cross-media content as implemented in these environments should also be
      supported by any modern presentation tool. This includes several
      different mechanisms that enable including parts of other presentations
      (e.g. slides), transcluding content from third-party document formats,
      and including content from open learning repositories.

     \paragraph{Connectivity}

      Connectivity for multi-device input and output has become more relevant
      in relation to presentation tools with the rise of social and mobile
      technologies. Multi-directional connectivity needs to be supported for
      several reasons. First, it is a requirement to enable the previously
      mentioned cross-media transclusion from external resources. Second,
      multi-directional connectivity is the basis of audience feedback via
      real-time response or voting systems \citep{dufresne-1} as well as other
      forms of multi-device interfaces.

     \paragraph{Interactivity}

      As mentioned earlier, content can be more interactive and the
      extensibility requirement addresses this issue since the intended
      architecture should support dynamic or interactive content and
      visualisations. However, traditional human input devices might not
      suffice for components offering a high level of interaction. As such, a
      presentation tool should facilitate the integration of other forms of
      input like gesture-based interaction using Microsoft's Kinect controller
      or digital pen interaction \citep{signer-2} as implemented by the
      PaperPoint \citep{signer-1} presentation tool.

     \paragraph{Post-Presentation Phase}

      Slide decks often play an important role as study or reference material,
      even if that was never their original goal. It is a trivial act to share
      traditional slide decks after a presentation, but this changes when the
      previously mentioned requirements are taken into account. The nonlinear
      navigation allows presenters to go through their content in a non-obvious
      order, and input from the audience might drive parts of a presentation,
      amongst other possible variables. Special attention should therefore be
      paid to the post-presentation phase. Playing back a presentation using
      the original navigational path, annotations and audience input should be
      made easy, while the content should also be made discoverable and
      reusable. With the rise and popularity of modern social media, there is a
      definite possibility to include the social aspect in a post-presentation
      phase through a content discussion mechanism.

  \section{\mxp Platform}
   \label{mxp-platform}

   This section presents the global architecture of the
   \mxp\footnote{http://mindxpres.com} crossmedia presentation platform as
   outlined in \figref{roels-1-fig-1}, which addresses the requirements
   presented in the previous section.

   \fig{roels-1-fig-1}{\mxp architecture}

   \subsection{Document Format and Authoring Language}

    A dedicated \mxp document format is used to store, structure and and
    reference content. Content is stored, structured and referenced in Each
    individual \mxp document contains the presentation's content itself and may
    also refer to some external content to be included. A new \mxp document can
    be constructed by hand similar to how \latex is authored, or --- in the
    near future --- it may be generated via a graphical authoring tool.
    Contrary to other presentation formats such as Slidy, S5 or OOXML, the \mxp
    authoring language abandons unnecessary HTML and XML specifics and focuses
    on a semantically more meaningful vocabulary. The syntax of the authoring
    language is almost entirely defined by plug-ins that enable the inclusion
    and visualisation of various media types and structures. To allow users
    some freedom in the way they present their information, the core \mxp
    presentation engine does little more than providing a runtime environment
    for plug-ins and lets them define the media types (e.g. video or source
    code) as well as structures (e.g. slides or graph-based content layouts).

    This also becomes apparent in the document format as every plug-in extends the
    available syntax. Any visual styling including different fonts,
    colours or backgrounds is achieved by applying specific themes to the
    underlying content.

   \subsection{Compiler}

    The compiler generates a self-contained portable \mxp presentation bundle
    based on a \mxp document. Although a \mxp document could be directly
    interpreted at visualisation time, we decided to create this intermediary
    step for a number of reasons. First, the compiler enables the creation of
    different types of presentations from the same \mxp document instance.
    This lets us not only create dynamic and interactive presentations but also
    more static output formats such as PDF documents for printing. Second, it
    is unwise to assume that there will always be an Internet connection
    available when giving a presentation. To overcome this possible issue, the
    compiler might create an offline version of a presentation with all
    necessary content pre-downloaded and included in the \mxp presentation
    bundle. Last but not least, the compiler might resolve incompatibility
    issues by, for instance, converting unsupported video formats or including
    certain HTML5 libraries.

   \subsection{\mxp Presentation Bundle}

    The dynamic \mxp presentation bundle contains the compiled content along
    with a portable cross-platform presentation runtime engine which enables
    more interactive and networked presentations. Resembling the original
    document, the compiled presentation content still consists of integrated
    content as well as references to external resources, such as online content
    that will be retrieved when the presentation is visualised. However, it
    should be noted that the content might have been modified by the compiler
    and, for example, been converted or extracted from other document formats
    that the runtime engine cannot process. References to external content may
    have been dereferenced by the compiler for offline viewing.

    A presentation bundle's core runtime engine consists of the three modules
    shown in \figref{roels-1-fig-1}. The \emph{content engine} is responsible
    for processing the content and linking it to the corresponding
    visualisation plug-ins. The \emph{graphics engine} provides all
    rendering-related functionality. For instance, some presenters may prefer a
    zoomable user interface because it provides a better overview of their
    content \citep{reuss-1}. This graphical functionality is also available to
    the plug-ins, which can make use of the provided abstractions. The
    \emph{communication engine} exposes a communication API which can also be
    used by plug-ins. It implements some basic functionality for fetching
    external content while also offering the possibility to form networks
    between multiple \mxp presentation instances as well as to connect to
    third-party hardware such as digital pens or clicker systems.

    Finally, the presentation bundle also contains a collection of
    \emph{themes} and \emph{plug-ins} as referenced by the presentation
    content. Themes may define visual styling on a global as well as on a
    plug-in level. The content engine encounters different content types and
    hands them over to the matching plug-in, which in turn uses the graphics
    engine to visualise the content.

   \subsection{Plug-in Types}

    \fig{roels-1-fig-2}{Structure plug-in examples}

    In order to attain the required flexibility, all non-core modules have been
    implemented as plug-ins. Even the most basic content types including text,
    images and bullet lists are handled through plug-ins. We distinguish
    between three major categories of plug-ins:

    \begin{itemize}

     \item \emph{Components} are the smallest elements of a presentation. The
     component plug-ins handle the visualisation for specific content types
     such as text, images, bullet lists, graphs or videos. The content engine
     invokes the corresponding plug-ins in order to visualise the content.

     \item \emph{Containers} are used to group and organise components in a
     specific way. One example of such a container is a slide, where each slide
     contains different content but also some recurring elements. For instance,
     every slide of a presentation can contain certain elements such as a
     title, a slide number and the author's name, all of which can be
     abstracted at a higher level. Another example is an image container that
     visualises its content as a horizontally scrollable list of images. It's
     important to observe that \mxp does not restrict us to the slide format
     and content can be laid out in many alternative ways.

     \item \emph{Structures} are high-level structures and layouts for
     components and containers. They may scatter content in a graph-like
     structure or they may clearly group it in sections like in a book. These
     are radically different ways of visualising and navigating content but the
     plug-in abstraction allows the user to easily switch between different
     presentation styles like the ones shown in \figref{roels-1-fig-2}.
     Structures differ from containers in that they do not restrict media types
     of their child elements in any way while they may influence the default
     navigational path through the content.

    \end{itemize}

   \subsection{Implementation}

    HTML5 and its related web technologies were chosen as the backbone for the
    \mxp presentation platform. Alternatives such as JavaFX, Flash or game
    engines were investigated as well, but HTML5 appeared to be the best
    option. The widely accepted HTML5 standard makes \mxp presentations highly
    portable, as any device with a recent web browser can display them,
    including smartphones and tablets. Moreover, HTML5 offers rich
    visualisation functionality by design and the inclusion of Cascading Style
    Sheets (CSS) and third-party JavaScript libraries makes it a powerful
    visualisation platform.

    \subsubsection{Document Format and Authoring Language}

     The \mxp document format that enables the simple expression of a
     presentation's content, structure and references is based on the
     eXtensible Markup Language (XML). \lstref{xml-1} shows a simple example
     of a presentation defined in our XML-based authoring language. The set of
     valid tags and their structure, apart from the \code{presentation} root
     tag, consists of what is provided by the available plug-ins.

     \begin{figure}[h!]
      \begin{lstxml}{xml-1}{Authoring a simple \mxp presentation}
<presentation>
  <slide title="Vannevar Bush">
    <bulletlist>
      <item>March 11, 1890 - June 28, 1974</item>
      <item>American Engineer, founder of Raytheon</item>
    </bulletlist>
    <image source="bush.jpg"/>
  </slide>
</presentation>
      \end{lstxml}
     \end{figure}

    \subsubsection{Compiler}

     The compiler has been implemented as a Node.js application. Not only does
     this accomodate the use of the compiler via a web interface or as a web
     service, but projects such as node-webkit also enable the compiler to be
     executed as a local offline desktop application. The decision to use
     server-side JavaScript was influenced by the fact that Node.js has the
     ability to bridge web and desktop technologies. On one hand, the framework
     facilitates interaction with other web services and allows us to work with
     HTML, JSON, XML and JavaScript visualisation libraries during compilation.
     On the other hand, the framework can carry out tasks for which web
     technologies are usually not suitable, including video conversion, legacy
     document format access, file system access or TCP/IP connectivity.

     To enable validation of a \mxp document in the XML format described above,
     an XML Schema exists which is augmented with additional constraints
     provided by the plug-ins. After validating the document, it is parsed and
     any discovered tags might trigger preprocessor actions defined by the
     plug-ins, such as the extraction of data from referenced legacy document
     formats (e.g. \ppt or Excel) or the conversion of an unsupported video
     format. Each tag is then converted to HTML5 and all information is encoded
     in the attributes of a \code{div} element. The HTML5 standard allows
     custom attributes that start with a \code{data-} prefix. \lstref{xml-2}
     hilights converted parts of the original XML document we saw in
     \lstref{xml-1}. Observe that no visualisation-specific information is
     included in the transformation, which merely results in a valid HTML5
     document ready to bundle into a self-contained package together with the
     presentation engine.

     \begin{figure}[h!]
      \begin{lstxml}{xml-2}{Transformed HTML5 presentation content}
<div data-type="presentation">
  <div data-type="slide" data-title="Vannevar Bush">
    <div data-type="bulletlist">
      ...
      \end{lstxml}
     \end{figure}

    \subsubsection{Presentation Engine}

     The presentation engine's main purpose is to create a visually appealing
     and interactive presentation based on the compiled HTML content. As
     \figref{roels-1-fig-1} shows, the presentation engine consists of several
     smaller components which enable plug-ins to implement powerful features
     with minimal effort. The combination of these components allows for rapid
     prototyping and evaluation of innovative visualisation ideas. A resulting
     \mxp presentation combining various structure, container and component
     plug-ins is shown in \figref{roels-1-fig-3}.

     \fig{roels-1-fig-3}{A \mxp presentation}

     \paragraph{Content Engine} The content engine is the first component that
      is activated when a presentation is loaded. It uses the well-known
      jQuery JavaScript library to process the content of the HTML
      presentation. Whenever a \code{div} element is discovered, the
      \code{data-type} attribute is read and the corresponding plug-ins are
      triggered in order to visualise the content.

     \paragraph{Graphics Engine} The graphics engine accomodates interesting
      new visualisation and navigation styles. Apart from some basic helper
      functions, it provides efficient panning, scaling and rotation via CSS3
      transformations and supports zoomable user interfaces as well as the more
      traditional navigation approaches.

     \paragraph{Communication Engine} The communication engine offers
      abstractions that enable plug-ins to retrieve external content at runtime.
      It also provides the architectural foundation to form networks
      between different \mxp instances and to integrate third-party hardware
      \citep{roels-2}.
      For the \mxp prototype, a small Intel Next Unit
      of Computing Kit (NUC) was used with high-end WiFi and Bluetooth modules to act as
      a central access point and provide the underlying network support. \mxp presentation
      instances use WebSockets to communicate with other \mxp instances via the
      access point. The access point also acts as a container for data
      adapters that translate input from third-party devices
      into a generic representation that can be used by the \mxp instances in
      the network. In order to transcend simple broadcast-based communication,
      a routing mechanism was implemented based on the publish-subscribe
      pattern, allowing plug-ins to subscribe to specific events or publish
      information. The communication engine supplies the foundation for audience
      response systems \citep{roels-2} or even full classroom communication
      systems where the creativity of plug-in developers is the only limit.

     \paragraph{Plug-ins} Plug-ins are implemented as JavaScript bundles
      consisting of a folder containing JavaScript files and other resources
      such as CSS files, images or other JavaScript libraries. As a first
      convention, a plug-in should contain a manifest file with a predefined
      name. The manifest describes the plug-in using metadata such as the
      plug-in name and version but also a list of tags it provides and handles
      to be used in a presentation. The plug-in claims unique ownership for
      these tags and is solely responsible for their visualisation if the
      content engine encounters them. As a second convention, a plug-in must
      implement at least one JavaScript object providing certain methods, one
      of them being the \code{init()} method which is called when the plug-in
      is loaded by the presentation engine. The plug-in may decide to load
      additional JavaScript or CSS via the provided dependency injection
      functionality. A second method it needs to implement is the
      \code{process()} method which is invoked with a pointer to the
      corresponding DOM node as a parameter by the content engine when it
      encounters a corresponding tag. A plug-in is free to modify the DOM tree
      and may also register callbacks to enable future interaction with the
      content.

     \paragraph{Themes} CSS is currently the driving technology behind a basic
      templating system. These themes offer styling either on a global or on a
      plug-in level. It has always been the intention to replace this system
      with a more advanced layout engine that steers away from templates, and
      part of that is incidentally one of the goals of this thesis. The
      intention is to provide layout functionality far beyond what can be
      attained using templates. However, the styling functionality will still
      be handled by the current system. In the future this system may still be
      replaced or enhanced to allow more dynamic styling using JavaScript.

   \subsection{Use Cases}

    To prove the merits of the architectural and technological choices, we
    demonstrate the extensibility and feasibility of \mxp as a rapid
    prototyping platform through demonstration of a number of content- and
    navigation-specific plug-ins that have been developed so far. Additional
    plug-ins for audience-driven functionality such as real-time polls, screen
    mirroring and navigational takeover can be found in \citep{roels-2}.

    \subsubsection{Structured Overview Plug-in}

     In Section \ref{mxp-platform} we described how structure plug-ins may
     alter and influence the way presentations are visualised and navigated. In
     order to illustrate this, a structure plug-in called \emph{structured
     layout} was implemented, to combine a zoomable user interface with the
     ability to group content into sections. The resulting visualisation of the
     \emph{structured layout} plug-in is displayed in \figref{roels-1-fig-3}.
     Whenever a new section is reached while navigating through the
     presentation, the view is zoomed out to provide an overview of the content
     within the section and to convey a sense of progress.

    \subsubsection{Slide Plug-in}

     Even though one of the main intentions of \mxp is to discard the concept
     of slides with all their limitations, it was deemed necessary to include
     support for this concept as well. As such, a slide-like container plug-in
     was created. While the benefits and issues of using slides with a fixed
     size are debatable, this plug-in was implemented as a testament to the
     framework's versatility. The main purpose of the slide plug-in is to
     produce a rectangular styleable component container with an optional title
     and some other information. Containers may also contribute functionality
     to layout their content. In this instance, the slide plug-in implements a
     quick and easy layout mechanism that allows the presenter to partition the
     slide into rows and columns. Slide containers are then assigned to these
     slots in the order that they are discovered. The use of the slide plug-in
     together with the resulting visualisation is depicted in
     \lstref{roels-1-fig-4}. This demonstrates the use of the image plug-in (a
     component plug-in) as well, which introduces a simple form of cross-media
     transclusion. A visualised external image can be cropped and filters (e.g.
     colour correction) may be applied without duplicating or modifying the
     original source.

     \begin{figure}[h!]
      \begin{subfigure}{0.53\textwidth}
       \vspace{-1em}
       \begin{lstxml*}
<slide layout="\60\40" title="Vannevar Bush">
 <bulletlist>
  <item>About
   <item>March 11, 1890 - June 28, 1974</item>
   <item>American Engineer</item>
   <item>Founder of Raytheon</item>
  </item>
  <item>...
  </item>
 </bulletlist>
 <image source="http://example.com/bush.jpg">
  <crop bounds="10%, 5%, -10%, -20%" />
 </image>
</slide>
       \end{lstxml*}
      \end{subfigure}
      \hfill
      \begin{subfigure}{0.43\textwidth}
       \fignl{roels-1-fig-4}
      \end{subfigure}
      \renewcommand{\figurename}{Listing}
      \renewcommand{\figureshortname}{Lst.}
      \cl{roels-1-fig-4}{Slide plug-in}
     \end{figure}

    \subsubsection{Enhanced Video Plug-in}

     When showing a video in an educational setting, we often need more
     functionality than the average video player can provide
     \citep{reuss-1}. \mxp offers an enhanced video plug-in as demonstrated in
     \lstref{roels-1-fig-5}, adding the possibility to overlay a video with text
     or arbitrary shapes. This overlay functionality can be used as a basic
     captioning system as well as to highlight items of interest during
     playback.

     Furthermore, there is an option to trigger certain events at specified
     times. One may mark certain points where a video should automatically
     pause at, highlighting an object and then continuing playback after a
     specified amount of time. Other features include the bookmarking of
     certain positions in a video for direct access and the possibility to
     display multiple videos in a synchronised manner. The enhanced video
     plug-in leverages the default HTML5 video player and overlays it with a
     transparent \code{div} element for augmentation. Currently it utilizes the
     HTML5 video API to synchronise the creation and removal of overlays but a
     SMIL-based implementation might be used in the future.

     \begin{figure}[h!]
      \begin{subfigure}{0.53\textwidth}
       \vspace{-1em}
       \begin{lstxml*}
<video source="vid.mp4">
 <caption start="0:00" duration="1500ms">
  Lecture 3 - Butterfly Species
 </caption>
 <pause start="0:43" duration="5s">
  <caption>
   The peacock butterfly (aglais io) ...
  </caption>
  <highlight x="30%" y="9%"
             width="35%" height="40%" />
 </pause>
</video>
       \end{lstxml*}
      \end{subfigure}
      \hfill
      \begin{subfigure}{0.43\textwidth}
       \fignl{roels-1-fig-5}
      \end{subfigure}
      \renewcommand{\figurename}{Listing}
      \renewcommand{\figureshortname}{Lst.}
      \cl{roels-1-fig-5}{Enhanced video plug-in}
     \end{figure}

 \newpage

    \subsubsection{Source Code Visualisation Plug-in}

     We have previously mentioned the issues involved with visualising complex
     resources such as source code. Our \mxp source code plug-in exports a
     \code{code} tag allowing the presenter to paste their code into a
     presentation and have \mxp visualise it nicely through syntax highlighting
     using the
     SyntaxHighlighter\footnote{http://alexgorbatchev.com/SyntaxHighlighter/}
     JavaScript library. Whenever the content engine encounters a \code{code}
     tag, this plug-in is invoked to beautify the code. It also automatically
     adds vertical scrollbars for larger segments of source code as illustrated
     in \lstref{roels-1-fig-6}.

     \begin{figure}[h!]
      \begin{subfigure}{0.53\textwidth}
       \vspace{-1em}
       \begin{lstxml*}
<code>
 <publications>
  <publication type="inproceedings">
   <title>An Architecture for Open Cross-Media
          Annotation Services</title>
   <author>
     <surname>Signer</surname>
     <forename>Beat</forename>
   </author>
   <author>
     <surname>Norrie</surname>
     <forename>Moira</forename>
   ...
</code>
       \end{lstxml*}
      \end{subfigure}
      \hfill
      \begin{subfigure}{0.43\textwidth}
       \fignl{roels-1-fig-6}
      \end{subfigure}
      \renewcommand{\figurename}{Listing}
      \renewcommand{\figureshortname}{Lst.}
      \cl{roels-1-fig-6}{Source code visualisation}
     \end{figure}

   \subsection{Discussion and Future Work}

    \mxp currently supports transclusion and cross-media content reuse through
    the use of plug-ins. For example, the image or video plug-in can visualise
    (and enhance) external resources, a dictionary plug-in could retrieve
    definitions on demand via a web service or we might create a plug-in that
    lets us import content (e.g. \ppt slides) from legacy documents at compile
    time. Nevertheless, the introduction of generic reuse tags in our document
    format is actively being investigated. This would allow the presenter to
    transclude arbitrary parts of other \mxp presentations. While the focus has
    been on the cross-media aspect of resources that can be used in a
    presentation, the cross-media publishing aspect might also be considered in
    the future via alternative compiler output formats.

    The creators of \mxp are aware that the current authoring of \mxp
    presentations faces some usability difficulties. The average presenter
    cannot be expected to construct an XML document or any CSS themes. In order
    to address this issue and further evaluate \mxp in real-life settings, a
    graphical \mxp authoring tool is currently being developed. They further
    intend to provide a central plug-in repository which would enable novice
    users to find, install and use new plug-ins via the authoring tool in a
    simple manner. In the long run, the use of monolithic documents is to be
    revised and a move towards repositories of semantically linked information
    based on the RSL hypermedia metamodel will be executed \citep{signer-3}.
    This will promote content reuse and sharing, while also creating
    opportunities for context-aware as well as semi-automated presentation
    authoring where relevant content is suggested by the authoring tool.

  \section{Layout}

   Proper layout is incredibly important when trying to transfer knowledge and
   information through written and visual media. Layout can help clarify
   boundaries and relations between pieces of information, by grouping and
   separating them appropriately. Layout is one component of a presentation's
   design, that --- combined with other decisions --- determines the number and
   nature of the visual representations of the information the creator wants to
   communicate, along with its format\footnote{The way the visual objects are
   realised (e.g. as text, graphics, UI widgets\ldots), and their attributes
   (e.g. color, texture, font\ldots)}. The layout of a presentation can have a
   tremenduous influence on its effectiveness in communicating information to,
   and obtaining information from, the audience it is meant to interact with.
   The importance of individual objects can be emphasised or minimised, and the
   connection between obects can be clarified or blurred. A well laid out
   presentation can provide a narrative for the viewer to discover, inferring
   correct links between the objects along the way, and to accomplish tasks
   quickly and correctly, increasing the presentation's effectiveness.

   Creating a good layout is almost never easy. People often spend more time on
   the layout of their presentation than the content. Most, if not all,
   decisions in layout are made by human beings. Some of them are professional
   designers who spend years learning and figuring out how to create effective
   layouts, and even then they may take hours or days to create even a single
   screen of a presentation. In fact, the more someone knows about proper
   layout and design, the more time they may spend perfectioning their work.
   However, sometimes time-critical information must be communicated and the
   layout process is too expensive and too slow to address these situations.
   This can be a serious problem (see also section \ref{nasa}). Many software
   packages have been developed to make this process easier, to get better
   results, to give more or less control to the creators. Many different
   approaches have been taken, and yet most of them still involve having a
   human being make the final decisions on the layout.

   There are tools like \ppt, which give you some guidelines and some templates
   but generally let you do your own thing. If your own thing is entirely
   different from any best practices on layout, nothing will stop you. Other
   tools like \latex give you complete control over every aspect of the layout,
   while setting some sensible defaults so that you can get a good-looking
   layout without much effort, while still letting you do whatever you want
   once you overcome the steep learning curve that separates the casual users
   from the experts. There are tools that combine the power of \latex with the
   comfort of WYSIWYG editors, bringing the casuals a bit closer to the
   experts. But all of those tools have one thing in common: every aspect of
   every layout they create has, at some point, been designed and decided upon
   by a human being.

   Aesthetics are a natural phenomenon, and the creation of aesthetically
   pleasing layouts is therefore a manifestation of our instincts. As with most
   instincts, it has proven difficult to translate this into a concept that can
   be understood by a computer. Moreover, it is still difficult to explain it
   in human terms, which --- according to a popular quote often attributed to
   Albert Einstein --- proves we don't fully understand it ourselves.

   When we look to other technologies, we do find some automated layout
   implementations. For example, the web has had to adapt to mobile devices
   with small screens over the past few years, and has done this gracefully by
   creating the concept of responsive design. In short, this allows websites to
   adapt their layout to any screen, no matter the size. While this is often a
   hard-coded difference, where effectively two or more versions of the same
   webpage are created aimed at different screen sizes, some websites take a
   more dynamic approach based on constraints. As the space the page is to be
   displayed on gets smaller, the layout algorithm may decide to display
   content below other content instead of side-by-side, it may scale images to
   fit the screen, it may even switch fonts and font sizes if necessary.

   This constraint-based technique is described in a few papers
   \citep{lok-1,hurst-1}, but has --- to our knowledge --- not been applied in
   any presentation software so far. This is surprising, as presentations often
   look like they could use some of this magic. A proper constraint-based
   layout algorithm could allow any user to drop content onto a slide, without
   worrying about clarity or even legibility, and the algorithm could take care
   of the rest. Of course, there are some limits in traditional slideware that
   may hinder this approach: if a user decides to put more content on a slide
   than there is physical room available, the algorithm could either make the
   content smaller or split it across several slides, but either solution may
   bring its own problems up. An advantage of ZUI's is that no matter how small
   the content gets, we can still zoom in to make it clear again\footnote{It
   should be noted that \mxp in its current form does not support this level of
   zooming. While the software can zoom out to provide an overview of the
   presentation while zooming in on the separate components, it is not yet
   possible to zoom in or out extremely to reveal 'hidden' parts of the
   presentation. This is something we encourage to look into and change,
   because it can greatly improve both our layout solution as well as the whole
   \mxp experience in general.}.

   \subsection{Algorithms}
    \label{related-algorithms}

    When researching layout algorithms, one will often come across the very
    active field of graph layout \citep{battista-1}. We will not go into the
    specifics of this field, as most of the issues with which it is concerned
    are specific to problems caused by the explicit visual representation of
    graph edges --- for example, the minimisation of edge crossing
    \citep{battista-2, shahrokhi-1}. The same applies to automated layout as
    referring to automated circuit layout for VLSI chip fabrication
    \citep{hu-1, lengauer-1} as well as automated placement of pieces to be cut
    from a bolt of cloth used to produce clothing \citep{milenkovic-1}.
    Contrary to presentation layouts (including graph layouts), these layouts
    do not attempt to make themselves understandable to the human mind, but
    rather are designed to meet the requirements of a fabrication process.
    While some techniques used therein definitely apply to our more general
    problem of automated presentation layout (e.g. general constraint solvers)
    others decidedly do not (e.g. bin-packing techniques \citep{hofri-1} that
    result in minimal area layouts at the expense of maintaining visually
    obvious relationships between objects).

   \subsection{Simple techniques}
    \label{simple-techniques}

    Most modern user interfaces are built with a UI toolkit (e.g., Sun
    JFC/Swing \citep{sun-1}, Microsoft Foundation Classes \citep{microsoft-1},
    and their predecessors, such as Xtk \citep{mccormack-1} or Tk
    \citep{ousterhout-1}) which provide some basic functionality such as
    creating buttons and windows. Toolkits usually include layout managers to
    assist the user interface designer in deciding how objects should be places
    inside a managed container. Layout managers allow the programmer to add
    objects to a container and optionally specify additional constraints while
    forgoing the need to specify the absolute position and size of every
    object. As such, it becomes possible to create layouts that adapt to
    changes in the container’s size.

    A layout manager dictates the positions and sizes for the objects under its
    control at run time, guided by a set of constraints defined by a simple
    layout policy on which the manager was based and parameters specified by
    the programmer. Strict horizontal (row) or vertical (column) layout,
    row-major or column-major layout where objects are placed in the next row
    or column to prevent exceeding their container’s boundaries, border layout
    that lets objects reside in the north, south, east, west, or center of the
    container as specified by the programmer, and grid layout in which objects
    are placed in one position (or straddling multiple positions) in a 2D grid,
    are some typical layout policies. Programmer-specified parameters indicate
    preferred, minimum, and maximum widths and heights of objects; and spacing,
    both between objects and between objects and the container’s edges. 

    A layout may be designed as a hierarchy of managed containers, each with
    their specific layout policies, on which additional constraints can be
    placed through programmer-specified parameters. Thus, a layout manager
    does not actually design the layout. It actually only instantiates the
    layout at run time based on the structure and parameters specified by the
    programmer. Designing a simple layout (e.g., four pictures lined up in
    row-major order) is easy for most programmers, but complex hierarchical
    layouts, while possible, are much more tedious and difficult, especially if
    any robustness is desired when resized.

    Commercial presentation systems intended primarily for sequential
    presentations (e.g. \ppt, Keynote, and \latex Beamer) offer a set of
    preauthored style “templates” (and the ability to create new ones) that can
    be applied to existing material. Compared to the parameterized layouts of
    UI toolkit layout managers, most of these template-based systems are
    simpler. However, users of these systems often move floating objects
    around by hand to guide or overrule simplistic placement policies.

   \subsection{Constraint satisfaction}
    \label{constraint-satisfaction}

    The vast majority of research in automated layout to date heavily
    emphasises constraint-based methods
    \citep{vanderzanden-1,borning-1,graf-1,hudson-3,kochhar-1,hudson-2,weitzman-2,myers-2}.
    Describing layouts as a set of constraints is very intuitive. The goal of a
    constraint-based automated layout system is to take a constraint network
    defining relations between objects, and generate the positions and sizes
    for each of the objects in the network. Any constraint-based automated
    layout system can be characterized by the kinds of constraints it observes;
    their description and the manner in which they are obtained, and resolved;
    and the way the system deals with constraint inconsistencies, loops and
    other hazards that might prevent the solution from converging.

    \subsubsection{Types of constraints}

%<TODO rework>

     Most constraints in a constraint-based automated layout system can be
     classified as either abstract or spatial. By abstract, we mean that the
     constraint describes a high-level relationship between two components that
     are to be included in the layout (e.g., “TEXT1 REFERENCES PIC1”). In
     contrast, spatial constraints enforce position or size restrictions on the
     components (e.g., “CAPTION1 BELOW PIC1”). Spatial constraints can be fed
     directly into a constraint solver for resolution, whereas abstract
     constraints must be processed and reduced to spatial constraints before the
     layout can be realized. The process of generating spatial constraints from
     the abstract constraints is often the most challenging part of creating an
     automated layout system.

     The choice of employing abstract or spatial constraints depends on the
     nature of the layout that the system is designed to generate. Many research
     systems employ both abstract and spatial constraints because they are
     general multimedia presentation tools \citep{feiner-1,weitzman-2,graf-1}.
     Other research initiatives are embodied in the form of libraries such as
     subArctic \citep{hudson-3,hudson-1} and the Garnet toolkit \citep{myers-2}
     that include extensions of “layout manager” type functionality with simple
     spatial constraints. Although automated layout systems for more limited
     environments can create effective layouts using only spatial constraints
     \citep{kosak-1}, the same can not be said for attempting to employ abstract
     constraints without spatial constraints. Figure 2 depicts what the
     difference in output might be between a system that considers only abstract
     constraints versus a system that takes into account both abstract and and
     spatial constraints. This issue is discussed further in Section
     \ref{spatialcon}.

     \paragraph{Abstract constraints}

      Abstract constraints are descriptions of high-level relationships between
      the various components that are to be placed into the layout. Abstract
      constraints such as “TEXT1 REFERENCES PIC1” and “TITLE IS IMPORTANT” are
      sufficiently high-level that content authors can easily specify them and
      are particularly effective for use in interactive systems because the
      author of the content needs no additional technical or artistic skill to
      specify them.

      Although one might think that “TEXT1 REFERENCES PIC1” implies that B and C
      are relatively close to each other in the generated layout, abstract
      constraints in and of themselves do not specify the position and size of
      the components of a layout. This is because the mapping between abstract
      constraints and spatial constraints is performed by a translation component
      before spatial constraints are passed to the numeric constraint solver. The
      abstract– spatial constraint translator can choose to map the abstract
      constraint “TEXT1 REFERENCES PIC1” into any set of spatial constraints.
      This might mean that the PIC1 is placed right next to text TEXT1, or that
      PIC1 is placed on a different page and some visual cue is left to guide the
      end user to it from TEXT1.

     \paragraph{Spatial constraints}
      \label{spatialcon}

      Spatial constraints are relations that directly express the geometric
      structure of the presentation. For instance, we may wish to force a certain
      block of text to appear beneath another block of text that the user is
      assumed to have read first. Another instance of spatial constraints would
      be to force all objects to occupy a space that is of a certain size or an
      integral multiple of that size.

      There are a number of reasons why we would want to impose spatial
      constraints. Perhaps the most prevalent reason is to improve upon the
      visual quality and aesthetics of the presentation. Many early automated
      layout systems are created from the perspective of computer science and
      mathematics alone \citep{beach-1}. Such systems tend to treat the problem
      as a purely theoretical question of tiling and use optimization techniques
      to find a solution \citep{luders-1}. These kinds of systems will often not
      take into account simple legibility rules (e.g., text should be placed into
      columns that run down the entire page rather than having blocks of random
      size packed onto the screen) and style guidelines (e.g., all captions go
      beneath their associated figures and spacing between a figure and
      surrounding text block should be the same everywhere). Figure 2 exemplifies
      what might happen in a system that employs abstract constraints without
      spatial constraints. A system that considers only abstract constraints will
      not be able to generate layouts with the same aesthetic appeal as systems
      that consider both because the system has no visual restrictions on where
      components of the layout are placed.

      The method by which the components are represented may place some kind of
      limitation on what kinds of spatial constraints may be used. One such issue
      that may arise is sometimes referred to as the “Cousins Problem,” an
      example of which is shown in Figure 3. This problem may arise if the data
      structure in which the components are being stored does not allow
      referencing one component’s children from a different component’s child.

      It seems intuitive that we would want to use concepts from graphic design
      to create legible and pleasing output. Some systems enforce the
      presentation to conform to a grid system, similar to those used to lay out
      newspapers \citep{muller-1,hurlburt-1}. In a grid system, every screen or
      page of the presentation is divided into an array of upright rectangles.
      Each object must occupy one or more complete rectangles. Figure 4 is an
      example of output from Feiner’s GRIDS system \citep{feiner-1} which designs
      layout grids that enforce a consistency between screens or pages of a
      presentation. One complication with employing grid systems is that a
      graphical component may need to be cropped, padded with a border or have
      its aspect ratio changed This is because uniform scaling of the object may
      not be sufficient to make the object occupy an integral number of grid
      rectangles.

      Automated layout systems for well-defined environments, such as network
      diagrams or label placement, often employ spatial constraints exclusively
      \citep{kosak-1,christensen-1}. These systems consider issues such as the
      proximity of the components being placed, the distance between a label and
      its target, and the possibility of confusing the end user by placing
      multiple labels that are sufficiently near the same target that the end
      user doesn’t know which label is associated with it. Abstract constraints
      are often used for formatting labels (larger cities have bigger names), but
      are generally not used for layout directly.

      Some systems allow the user to specify abstract data constraints separately
      from spatial constraints. This allows for a logical single presentation to
      have many different “skins,” opening the door for a single presentation to
      be displayed using different media \citep{weitzman-2}. This is particularly
      effective for interactive layout systems that might want to maintain a
      separation between content authors and “layout experts.” A similar approach
      that leverages this concept is to build the spatial constraints into the
      system, thereby eliminating the need for human intervention to specify
      spatial constraints for each layout to be generated. Feiner’s GRIDS is an
      example of a such system \citep{feiner-1}.

      Spatial constraints are sometimes used to increase the efficiency of the
      constraint solver. For instance, a constraint might be placed on all
      objects of a certain type that permits them to be resized in only one
      direction \citep{linton-1}. Similarly, imposing the constraint of a
      quantized display permits the use of fast fixed point and integer
      programming techniques when resolving the set of constraints.

    \subsubsection{Expressing constraints}

     Intuitively it would seem best to define a formal grammar to describe the
     method by which the constraints are expressed. This approach benefits from
     being able to leverage a rich body of existing research for manipulating
     and parsing constraints. A rich grammar might be very flexible and
     expressive and translate into better layouts \citep{weitzman-1}. An example
     of a grammar for use in a layout system is shown in Figure 6. However,
     powerful and expressive grammars may also be difficult to use. This is
     especially true of grammars or ontologies that attempt to be extremely
     general and all-encompassing. In addition, a very complex solver may be
     necessary to process the information present in such a system. As one might
     imagine, it is extremely difficult to create a system that describes the
     set of all possible high-level relationships between components of a
     presentation, although this has been explored for the use of automatic
     graphics generation \citep{zhou-1}.

     Another extremely powerful approach is to express the constraints in terms
     of Boolean predicates \citep{graf-1}. This approach alleviates some of the
     concerns that arise from the more expressive grammar and relational grammar
     approaches by limiting the space of what can be expressed. The use of
     Boolean predicates also eases the process of solving the set of constraints
     as the input needs little or no translation before being passed to the
     solver.

    \subsubsection{Obtaining constraints}

     One of the most important practical issues in implementing a
     constraint-based automated layout system is determining where to obtain the
     constraints. Approaches that have been tried range from fully automated to
     the computer making suggestions.

     Many automated layout systems implement abstract constraints by gathering
     them from structured input data
     \citep{mackinlay-1,casner-1,borning-1,beach-1}. These systems take tables
     of numeric data and automatically create presentations. The structure of
     the data provides all the relationships that are needed to generate the
     layout. Other systems that are designed for multimedia layout have
     languages to explicitly specify the abstract constraints to describe
     relationships such as “author-of,” “description-of” and “precedes” between
     the components \citep{weitzman-2,graf-1}. The assumption that input data is
     readily available in a structured form is becoming increasingly valid
     because the information that we create is beginning to be stored in more
     structured formats \citep{bray-1}. Such work is prevalent in the layout
     modules of automated graphics generation systems \citep{zhou-2}.

     \paragraph{Interactive specification}

      Interactive constraint specification systems are also extremely popular,
      but suffer from the obvious limitation that they require user input. Some
      systems are designed to help graphically naive content authors create
      professional quality layouts. Others are meant to reduce the amount of time
      a graphic designer needs to spend on a layout.

      Most systems that take interactive input do so for spatial constraints
      \citep{singh-2,hudson-2,borning-1}. This is because it is easy to create
      graphical user interfaces that allow the user to interactively place or
      adjust components on the screen. Although providing a graphical user
      interface to specify abstract constraints is not unheard of, abstract
      constraints tend not to need adjustment. Roth’s SAGE system \citep{roth-1}
      allows a user to associate database records with visual elements.

      Some of the interactive systems require the user to specify the high-level
      design of the document and then automatically generate the final result
      \citep{kim-1}. This approach is very useful in situations where the goal is
      to enable a content author to create layouts without the need for
      intervention by a “layout expert.” Some other systems take the opposite
      approach where the system produces the initial layout and allows the user
      to refine it \citep{singh-1}. These systems are more applicable in
      situations where the goal is to save the amount of time that a graphic
      designer needs to spend to create the layout.

     \paragraph{Automated extraction}

      Fully automated constraint extraction is the least explored method of
      obtaining constraints. Some work has been done in integrating natural
      language techniques with automated layout \citep{roth-2}. This is
      particularly effective if natural language generation is being employed to
      create the content. Since the content generators are computer programs, it
      is much easier to have the generator send abstract that describes
      relationships between components as well as markup the text with flags
      denoting which parts are particularly important.

      Another method that has been explored is to extract abstract constraints
      from the entity relationships found in SQL databases \citep{pizano-1}.
      Unlike the natural language generation system that passes additional
      information to the layout system, in this approach abstract constraints are
      derived from data structures that were originally intended for use
      elsewhere.

    \subsubsection{Constraint solvers}

     A constraint-based automatic layout system must have some way to resolve
     the constraints with which it is presented. Formally, automated layout
     techniques all solve a form of the constraint satisfaction problem (CSP)
     \citep{mackworth-2,mackworth-1}. Both randomized and deterministic
     algorithms have been applied to solve the problems in this field. In
     general, the constraint solvers employed can be categorized as applying
     either a local or a global methodology.

     \paragraph{Local techniques}

      Local constraint solvers attack the constraint satisfaction problem
      bottom-up. This might be compared to inductive reasoning, where a small
      subset of the universe is first solved. Two routes can be taken to solv the
      rest of the constraints and create the final presentation. The first
      approach is to solve many small subsets of the constraints independently
      and then run a second resolution phase to combine the results. An
      alternative approach is to iteratively resolve constraints at the border
      between the constraints that have already been solved and those that have
      yet to be considered \citep{nilsson-1}.

      Using a local-resolution technique can be problematic if the solver
      encounters local minima \citep{borning-2}. By resolving small subsets
      first, the solver may make decisions that bring the system to a suboptimal
      final solution. The advantage, however, is that local-resolution techniques
      usually execute much faster than global techniques.

     \paragraph{Global techniques}

      Global constraint solvers attack the constraint satisfaction problem from
      the top down. Unlike local techniques, global techniques generally do not
      suffer from the problem of local minima, but require more computation time.
      To address the issue of additional computation time, numeric solvers that
      use iterative approximation techniques have been applied
      \citep{kurlander-1}. Randomized computation techniques (e.g., genetic
      algorithms and simulated annealing) have also been applied for label
      placement \citep{christensen-2}.

    \subsubsection{Inconsistency policies}

     If the set of constraints is sufficiently large, there is a strong
     likelihood that there will be some problems. In particular, some
     constraints may contradict others and possibly make the system of
     constraints unsolvable. A resolution policy must be specified to generate a
     layout in these cases.

     Some systems take a very simple approach to inconsistency by avoiding it.
     Rather than bogging the system down with inconsistency handling, the
     grammar used to articulate the constraints is designed in such a way that
     cycles cannot occur \citep{weitzman-2}.

     Another popular method for handling inconsistency is to apply priorities to
     the constraints \citep{graf-1}. By permitting each constraint to have an
     inherent priority, the system can make intelligent decisions about which
     constraints to drop should a contradiction be encountered. A problem can
     still occur here if two conflicting constraints have the same priority. In
     this case, the system can use the AI technique of applying a tie-breaking
     strategy (e.g., first-come first-served or pick one randomly) so that the
     layout can be generated \citep{nilsson-1}. Priorities are critical for
     generating effective layouts in systems where there are complex networks of
     both abstract and spatial constraints. For example, the enforcement of the
     grid in a system that employs design grids must take precedence over all
     other constraints.

%</TODO rework>

   \subsection{Learning techniques}
    \label{learning-techniques}

    Researchers have applied machine learning to many automated multimedia
    authoring systems. This includes speech synthesis \citep{pan-1} and natural
    language generation \citep{kamimura-1}, as well as to graph layout
    \citep{masui-1}. However, most automated layout systems do not leverage the
    large body of existing work by the AI community in machine learning.

%<TODO rework>

    Automated layout systems that do have some form of learning tend to use it
    during the interactive specification of constraints
    \citep{myers-1,borning-1}. These systems do not implement full machine
    learning systems. Rather, they try to “learn” based on interacting with the
    user. The Marquise system \citep{myers-1} allows a user to set the system
    into a training mode where the relative locations of components are
    demonstrated to the system. Spatial constraints that will be used to
    generate the layout are then extracted from this interaction with the user.
    If the constraints cannot be extracted, the system falls back to having the
    user specify the position explicitly as a LISP function. Borning’s
    \citep{borning-1} ThingLab is similar in that it allows for demonstration
    of constraints, but also adds the ability to demonstrate animation.

    Some recent work in automated graphics generation has also explored the use
    of learning techniques \citep{zhou-3}. Zhou divides the space of rules that
    need to be acquired for presentation generation into three categories:
    information learning space, visual learning space and rule learning space.
    Visual learning space is directly related to spatial constraints, and thus
    is similar to Myer’s and Borning’s work. Unlike Marquise and ThingLab
    however, Zhou’s system employs full-strength machine learning that can be
    fully automated by providing the system with a large dataset of
    presentations designed by a “layout expert” in addition to the interactive
    methods seen in other work that employs learning techniques.

%</TODO rework>

