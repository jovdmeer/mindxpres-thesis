% vim:ts=1:et:nospell:spelllang=en_gb:ft=tex

 \chapter{Related work}

  \emph{This chapter's content is largely based on ``MindXpres: An Extensible
  Content-driven Cross-Media Presentation Platform'' \citep{roels-1}.}

  \section{Background}

   The importance of digital presentations in this day and age cannot be
   understated. Millions of presentations are created every day, supporting the
   oral transfer of knowledge and playing an important role in educational
   settings. Their origins as tools for creating physical media such as
   photographic slides or transparencies for overhead projectors are still
   reflected in the underlying concepts and principles of slide-based
   presentation tools. The rectangular boundaries of a slide, and the linear
   navigation between slides, are still restrictions we face today in digital
   presentations. Tufte argues that these concepts of slideware have a negative
   impact on the effectiveness of knowledge transfer \citep{tufte-1}. While
   the presenter is compelled to squeeze complex ideas into a linear sequence
   of slides, those ideas are rarely sequential by nature, resulting in a loss
   of relations, overview and details. An initial approach to address these
   issues might involve creating minimalistic presentations or introducing some
   structure via a table of contents. Sadly, when complex knowledge or other
   pieces of rich information need to be presented “as is” \citep{farkas-1} ---
   as in the domain of learning --- this does not work.

   One of the main issues with traditional slideware presentations is their
   monolithic nature, especially when content is spread over many
   self-contained presentation files. ``Reusing'' previous work involves either
   switching between files while giving a presentation or duplicating some
   slides in the new presentation. It should be noted that this issue is not
   limited to the reuse of single slides: there is an ever increasing wealth of
   resources available for reuse, spread over a wide spectrum of distribution
   channels and formats. The possibility to include content by reference or
   transclusion \citep{nelson-1} may contribute in crossing the boundaries
   between different types of media and prove beneficial in the context of
   modern cross-media presentation tools.

   The difference in functionality between the authoring of content and its
   visualisation is striking as well. The primary editors consist of mostly
   toolbars and buttons used for selecting and specifying the way content
   should be visualised, while support for authoring the content itself is not
   quite as extensive. Modern slideware has grown to include basic multimedia
   types such as videos, but most content is still rather static. It is, for
   example, not possible during a presentation to easily switch from a bar
   chart to a pie chart data visualisation, or to dynamically change some
   values in the represented data and immediately see the effect in the graph,
   which could be beneficial for knowledge transfer \citep{holzinger-1}. The
   audience could also be more actively involved in the presentation, through
   audience response and classroom connectivity systems providing multi-device
   interfaces allowing to share knowledge and results during as well as after a
   presentation. The evolution of presentations is reminiscent of the Web2.0
   movements where users have switched roles from purely consuming content to
   contributing as well, content has become more dynamic and interactive, and
   service-oriented architectures (``The Cloud'') have ensured decentralisation
   of content.

   In order to move a step towards the next generation of cross-media
   presentation tools, it is essential to allow the rapid prototyping and
   evaluation of new concepts for the representation, visualisation and
   interaction with content.

   Before discussing the requirements for a new generation of presentation
   tools, we briefly introduce existing slideware solutions. Afterwards, we
   describe the architecture of \mxp, its extensible nature and its plug-in
   mechanism. The HTML5-based implementation of \mxp is then discussed through
   demonstration of several use cases and \mxp plug-ins.

   A specific issue with slideware we'd like to focus on in this thesis, is the
   trouble with layout in presentations. It can be hard to display the content
   you want in a way that's clear, informative and nice to look at. The vast
   majority of layouts created today is mostly done by hand: a human graphic
   designer or ``layout expert'' makes most, if not all, of the decisions about
   the position and size of the objects to be presented \citep{lok-1}. Most
   software offers some templates, allowing you to drop pictures and text into
   predefined slots and places on a slide, but then those templates have been
   defined by someone else too. Computer-generated layout is rare and usually
   not quite up to the task.

   \mxp is among the software packages offering templates, in that layout is
   handled by whichever plug-in you choose, but so far no plug-ins have defined
   dynamic layout algorithms, rather sticking to predefined ways to put text
   and pictures on slides. But as \mxp does not constrain us to the limits of
   slides, this should be seen as an opportunity to offer dynamic layout as
   well. After all, if we're not limited to a certain area within which our
   content should fit, it should be much easier to put content next to each
   other in a way that makes sense.

  \section{Existing solutions}

   Since digital slideware was first introduced, their influence, advantages
   and disadvantages have been studied extensively. There have been studies
   acknowledging the benefits of slideware as a teaching asset
   \citep{holzinger-1}, while others have been less positive. Tufte
   \citeyearpar{tufte-1} heavily criticises slideware for its infatuation with
   outdated concepts. He discusses the many ramifications of dimensional and
   structural limitations as well as linear navigation, and points out the
   discrepancy with how the human mind works. Amongst Tufte's conclusions, and
   also confirmed by Adams \citep{adams-1}, is the suggestion that slide-based
   presentations are not appropriate for every kind of knowledge transfer and
   especially not in a scientific context. Recent work shows the importance
   towards the learning process of integrating content into the bigger picture,
   both structurally and visually \citep{gross-1}, which is affected by the
   navigation and visualisation.

   Several approaches have been proposed to offer non-linear navigation.
   CounterPoint \citep{good-1}, Fly \citep{lichtschlag-1} and Prezi, provide
   Zoomable User Interfaces (ZUIs) which offer virtually unlimited space.
   Microsoft has experimented with this concept as well in pptPlex. Other
   approaches to escape the confines of the slide have been noticed, like
   MultiPresenter \citep{lanir-1} or tiling slideshows \citep{chen-1}.
   PaperPoint \citep{signer-1} and Palette \citep{nelson-2} additionally
   facilitate the non-linear navigation of digital presentations consisting of
   slide selection through augmented paper-based interfaces. Lastly, a category
   of authoring tools exists which use hypermedia to implement varying paths
   through a set of slides. NextSlidePlease \citep{spicer-1} enables users to
   define a weighted graph of slides, and tries to suggest navigational paths
   based on the link weights and the remaining presentation time. Microsoft
   cultivates this idea in their HyperSlides \citep{edge-1} project. Garcia
   \citep{garcia-1} has additionally explored the potential of \ppt* as an
   authoring tool for hypermedia-based presentations.

   \ppt* was officially released in 1990, with Windows 3.0 \citep{austin-1}. It
   had originally been developed as Presenter, but trademark issues caused a
   name change early on. It was also originally build for the Macintosh, which
   may seem surprising nowadays but was actually common practice back then
   since the Macintosh was widely regarded as a better development environment,
   more mature, more stable and capable of far better performance and
   visualisations. Some may argue this still rings true today.

   Since then, it has grown to be the world's most popular slide show
   presentation program, alledgedly having been installed on over 1 billion
   computers worldwide, and being used on average 350 times \emph{per second}
   \citep{parks-1}. In 2012, it had a market share of 95\%, leaving the other
   5\% to be shared by alternatives such as Apple's Keynote, Prezi, SlideRocket
   and others. While this number is declining, it may not be going as fast as
   many people think. As most readers of this thesis have heard before, over 30
   million \ppt presentations are created every day, for all kinds of purposes,
   with good and bad results both presentation-wise and goal-wise.

   To reuse content in existing presentation tools, that content needs to be
   duplicated, which results in a multitude of redundant copies that need to be
   kept consistent with each other: if one copy is changed, all the others must
   be changed in the same way to prevent inconsistencies and mistakes. While
   some attempts have been made to solve this problem, there is still a long
   way to go. When looking for document formats designed to server more general
   educational purposes, we find formats such as the Learning Material Markup
   Language (LMML) \citep{suss-1}, the Connexions Markup Language (CNXML) and
   the eLesson Markup Language (eLML) \citep{fisler-1}. All of these formats
   share their focus on the reuse of content, but all of them attempt this at a
   relatively high granularity level. Content can be organised in lessons or
   modules, and users are encouraged to use these, as a whole, in their
   teaching. When we investigated the formats more closely, we observed that
   outgoing links to external content were supported, but
   transclusion\footnote{The inclusion of content via references} was not. In
   relation to presentations, Microsoft's Slide Libraries exist as central
   repositories that store slides to enable slide sharing and reuse within an
   organisation. The dependency on SharePoint might represent a hurdle for some
   users, as not everyone has the ability and opportunity to set up such a
   server. A more significant issue is the fact that slides still need to be
   searched and manually copied into presentations. Keeping slides in the
   repository and in other presentations is the responsibility of the authors
   of those slides and those presentations, as no automatic update system is
   provided. SlideRocket and SlideShare are both similar tools showing
   intentions and providing functionality for content reuse. The SliDL
   \citep{canos-1} research framework works much like Microsoft's Slide
   Libraries, in that it allows for storage and tagging of slides in a database
   for reuse, but also in that it shares the same shortcomings. The ALOCOM
   \citep{verbert-1} framework aimed at flexible content reuse is built upon a
   content ontology and a (de)composition framework for legacy documents
   including \ppt documents, Wikipedia pages and SCORM content packages.
   However, ALOCOM may be too rigid for evolving presentation formats, and it
   currently only supports the authoring phase, although the tool does succeed
   in decomposing legacy documents as advertised.

   Aside from the similarities in the Web's and presentation environments'
   evolution, some of the problems mentioned in this section can find their
   solutions in the context of the Web. It should not come as a surprise then,
   that web technologies are being used more often recently in the realisation
   of presentation solutions. The Simple Standards-based Slide Show System
   (S5)\footnote{http://meyerweb.com/eric/tools/s5/} is an XHTML-based
   slideshow file format that enforces the standard slideware model. The W3C's
   Slidy \citep{raggett-1} initiative offers another presentation format based
   on the classical slideware model. Both of these formats have some valuable
   properties. They encourage a clean separation of content and visualisation
   through the use of CSS themes. The design is resolution independent, and the
   layout and font size adjust to the available screen real estate. Last but
   not least, some more recent HTML5-based presentation solutions such as
   impress.js, deck.js, Shower or reveal.js. Cross-device support is one of the
   most important advantages to leverage when using a well-known open standard
   such as HTML. However, as all of these solutions display some restrictions
   in terms of visualisation, navigation, and cross-media support, they are
   unfortunately too limited for our needs.

   The tools and projects discussed in this section mostly focus on
   distinguishing novel ideas for presentations. Nevertheless, the different
   concepts introduced in these tools don't offer interoperability between
   them. One project may focus on the authoring, another one fixates on novel
   content types and a third solution supplies radically new navigation
   mechanisms. Slideware tools may often allow third-party extensions but the
   API exposed to plug-in developers is usually limited by the software's
   underlying model. As an illustration, \ppt supports interaction from
   plug-ins with the presentation model, but the model dictates that a
   presentation consists of a sequence of slides. Many existing web-based
   presentation formats share this flaw. Because of this, we see a need for an
   open presentation platform such as \mxp to support innovation by
   contributing the necessary modularity and interoperability \citep{bush-1}.

   It is perhaps surprising that, to our knowledge, currently no tools exist to
   calculate dynamic layouts of content in slideware. Existing solutions
   include template systems, sometimes very fine-grained like \latex allowing
   you to define templates for every single layout choice, usually more coarse
   like \ppt* or Apple Keynote using Master Slides to define different layouts
   on a per-slide basis, and always with the option of letting the user
   customise the layout by hand, literally manually moving the content to the
   exact place where we want it, unhindered by style guides, good practices or
   common sense. This has resulted in mindboggling layout choices involving
   enormous amounts of tiny text crammed onto one slide, or pictures strewn
   across a slide overwhelming the audience with too much information at once.

  \section{New solutions}

   Here we propose a set of requirements to establish a wide range of
   presentation styles and visualisations. This set has been compiled based on
   a review of the more recent presentation solutions discussed in the previous
   section.

     \paragraph{Non-linear Navigation} As we mentioned before, traversing
      slides in a linear fashion is a remnant of the way early photographic
      slides worked. Over the years, people have grown used to this form of
      navigation despite the inconveniences. If the presenter unexpectedly
      needs to show anything other than the next or previous slide (e.g. to
      answer a question from the audience), they either need a considerable
      amount of time to scroll forwards or backwards, or they have to switch to
      the slide sorter view, to find the desired slide. Also troubling is the
      lack of any functionality allowing a single slide to be included multiple
      times throughout the presentation without duplicating the slide in
      question, meaning if any change has to be made to that slide the same
      change has to be performed on all copies. This poses the risk of
      overlooking some copies, introducing inconsistencies and facilitating
      mistakes. There are several manners in which this lack of flexible
      navigation might be addressed, including the possibility to define
      non-linear navigation paths \citep{spicer-1,edge-1} or zoomable user
      interfaces (ZUIs) \citep{good-1,lichtschlag-1,haller-1}.

     \paragraph{Separation of Content and Presentation} Similar to the approach
      of \latex and other professional typesetting systems, content should be
      written in a standardised way with visualisation being handled
      automatically by the typesetting system. The clear separation between
      content and presentation makes the presentation tool handle the
      visualisation, allowing the authors of a presentation to focus on the
      content. Additionally, this facilitates experimentation with different
      visualisations. \latex does have a document class called Beamer which was
      designed specifically for presentations, but while we were inspired by
      its structured and content-driven approach, the content-related
      functionality and the visualisation possibilities are too limited to be
      considered as a basis for an extensible presentation tool.

     \paragraph{Extensibility} Rapidly prototyping innovative navigation and
      visualisation techniques, but also new content types and presentation
      formats, should be easy in order for a presentation tool to be successful
      as an experimental platform for new presentation concepts. It should be
      possible to add or replace specific components without requiring changes
      in the core. A presentation tool should provide a modular architecture
      with loosely coupled components to be truly extensible. Note that this
      type of extensibility should be offered on the level of content types as
      well as for the visualisation engine and content structures.

     \paragraph{Cross-Media Content Reuse} We have previously briefly mentioned
      the lack of content reuse in existing presentation tools. Even though
      there is a wealth of open education material available, it is rather
      difficult to use this content in presentations. However, the concept of
      transclusion does work well for digital documents and parts of the Web
      (e.g. via the HTML img tag). The seamless integration of external
      cross-media content as implemented in these environments should also be
      supported by any modern presentation tool. This includes several
      different mechanisms that enable including parts of other presentations
      (e.g. slides), transcluding content from third-party document formats,
      and including content from open learning repositories.

     \paragraph{Connectivity}

      Connectivity for multi-device input and output has become more relevant
      in relation to presentation tools with the rise of social and mobile
      technologies. Multi-directional connectivity needs to be supported for
      several reasons. First, it is a requirement to enable the previously
      mentioned cross-media transclusion from external resources. Second,
      multi-directional connectivity is the basis of audience feedback via
      real-time response or voting systems \citep{dufresne-1} as well as other
      forms of multi-device interfaces.

     \paragraph{Interactivity}

      As mentioned earlier, content can be more interactive and the
      extensibility requirement addresses this issue since the intended
      architecture should support dynamic or interactive content and
      visualisations. However, traditional human input devices might not
      suffice for components offering a high level of interaction. As such, a
      presentation tool should facilitate the integration of other forms of
      input like gesture-based interaction using Microsoft's Kinect controller
      or digital pen interaction \citep{signer-2} as implemented by the
      PaperPoint \citep{signer-1} presentation tool.

     \paragraph{Post-Presentation Phase}

      Slide decks often play an important role as study or reference material,
      even if that was never their original goal. It is a trivial act to share
      traditional slide decks after a presentation, but this changes when the
      previously mentioned requirements are taken into account. The nonlinear
      navigation allows presenters to go through their content in a non-obvious
      order, and input from the audience might drive parts of a presentation,
      amongst other possible variables. Special attention should therefore be
      paid to the post-presentation phase. Playing back a presentation using
      the original navigational path, annotations and audience input should be
      made easy, while the content should also be made discoverable and
      reusable. With the rise and popularity of modern social media, there is a
      definite possibility to include the social aspect in a post-presentation
      phase through a content discussion mechanism.

  \section{\mxp Platform}
   \label{mxp-platform}

   This section presents the global architecture of the
   \mxp\footnote{http://mindxpres.com} crossmedia presentation platform as
   outlined in \figref{roels-1-fig-1}, which addresses the requirements
   presented in the previous section.

   \fig{roels-1-fig-1}{\mxp architecture}

   \subsection{Document Format and Authoring Language}

    A dedicated \mxp document format is used to store, structure and and
    reference content. Content is stored, structured and referenced in Each
    individual \mxp document contains the presentation's content itself and may
    also refer to some external content to be included. A new \mxp document can
    be constructed by hand similar to how \latex is authored, or --- in the
    near future --- it may be generated via a graphical authoring tool.
    Contrary to other presentation formats such as Slidy, S5 or OOXML, the \mxp
    authoring language abandons unnecessary HTML and XML specifics and focuses
    on a semantically more meaningful vocabulary. The syntax of the authoring
    language is almost entirely defined by plug-ins that enable the inclusion
    and visualisation of various media types and structures. To allow users
    some freedom in the way they present their information, the core \mxp
    presentation engine does little more than providing a runtime environment
    for plug-ins and lets them define the media types (e.g. video or source
    code) as well as structures (e.g. slides or graph-based content layouts).

    This also becomes apparent in the document format as every plug-in extends the
    available syntax. Any visual styling including different fonts,
    colours or backgrounds is achieved by applying specific themes to the
    underlying content.

   \subsection{Compiler}

    The compiler generates a self-contained portable \mxp presentation bundle
    based on a \mxp document. Although a \mxp document could be directly
    interpreted at visualisation time, we decided to create this intermediary
    step for a number of reasons. First, the compiler enables the creation of
    different types of presentations from the same \mxp document instance.
    This lets us not only create dynamic and interactive presentations but also
    more static output formats such as PDF documents for printing. Second, it
    is unwise to assume that there will always be an Internet connection
    available when giving a presentation. To overcome this possible issue, the
    compiler might create an offline version of a presentation with all
    necessary content pre-downloaded and included in the \mxp presentation
    bundle. Last but not least, the compiler might resolve incompatibility
    issues by, for instance, converting unsupported video formats or including
    certain HTML5 libraries.

   \subsection{\mxp Presentation Bundle}

    The dynamic \mxp presentation bundle contains the compiled content along
    with a portable cross-platform presentation runtime engine which enables
    more interactive and networked presentations. Resembling the original
    document, the compiled presentation content still consists of integrated
    content as well as references to external resources, such as online content
    that will be retrieved when the presentation is visualised. However, it
    should be noted that the content might have been modified by the compiler
    and, for example, been converted or extracted from other document formats
    that the runtime engine cannot process. References to external content may
    have been dereferenced by the compiler for offline viewing.

    A presentation bundle's core runtime engine consists of the three modules
    shown in \figref{roels-1-fig-1}. The \emph{content engine} is responsible
    for processing the content and linking it to the corresponding
    visualisation plug-ins. The \emph{graphics engine} provides all
    rendering-related functionality. For instance, some presenters may prefer a
    zoomable user interface because it provides a better overview of their
    content \citep{reuss-1}. This graphical functionality is also available to
    the plug-ins, which can make use of the provided abstractions. The
    \emph{communication engine} exposes a communication API which can also be
    used by plug-ins. It implements some basic functionality for fetching
    external content while also offering the possibility to form networks
    between multiple \mxp presentation instances as well as to connect to
    third-party hardware such as digital pens or clicker systems.

    Finally, the presentation bundle also contains a collection of
    \emph{themes} and \emph{plug-ins} as referenced by the presentation
    content. Themes may define visual styling on a global as well as on a
    plug-in level. The content engine encounters different content types and
    hands them over to the matching plug-in, which in turn uses the graphics
    engine to visualise the content.

   \subsection{Plug-in Types}

    \fig{roels-1-fig-2}{Structure plug-in examples}

    In order to attain the required flexibility, all non-core modules have been
    implemented as plug-ins. Even the most basic content types including text,
    images and bullet lists are handled through plug-ins. We distinguish
    between three major categories of plug-ins:

    \begin{itemize}

     \item \emph{Components} are the smallest elements of a presentation. The
     component plug-ins handle the visualisation for specific content types
     such as text, images, bullet lists, graphs or videos. The content engine
     invokes the corresponding plug-ins in order to visualise the content.

     \item \emph{Containers} are used to group and organise components in a
     specific way. One example of such a container is a slide, where each slide
     contains different content but also some recurring elements. For instance,
     every slide of a presentation can contain certain elements such as a
     title, a slide number and the author's name, all of which can be
     abstracted at a higher level. Another example is an image container that
     visualises its content as a horizontally scrollable list of images. It's
     important to observe that \mxp does not restrict us to the slide format
     and content can be laid out in many alternative ways.

     \item \emph{Structures} are high-level structures and layouts for
     components and containers. They may scatter content in a graph-like
     structure or they may clearly group it in sections like in a book. These
     are radically different ways of visualising and navigating content but the
     plug-in abstraction allows the user to easily switch between different
     presentation styles like the ones shown in \figref{roels-1-fig-2}.
     Structures differ from containers in that they do not restrict media types
     of their child elements in any way while they may influence the default
     navigational path through the content.

    \end{itemize}

   \subsection{Implementation}

    HTML5 and its related web technologies were chosen as the backbone for the
    \mxp presentation platform. Alternatives such as JavaFX, Flash or game
    engines were investigated as well, but HTML5 appeared to be the best
    option. The widely accepted HTML5 standard makes \mxp presentations highly
    portable, as any device with a recent web browser can display them,
    including smartphones and tablets. Moreover, HTML5 offers rich
    visualisation functionality by design and the inclusion of Cascading Style
    Sheets (CSS) and third-party JavaScript libraries makes it a powerful
    visualisation platform.

    \subsubsection{Document Format and Authoring Language}

     The \mxp document format that enables the simple expression of a
     presentation's content, structure and references is based on the
     eXtensible Markup Language (XML). \lstref{xml-1} shows a simple example
     of a presentation defined in our XML-based authoring language. The set of
     valid tags and their structure, apart from the \code{presentation} root
     tag, consists of what is provided by the available plug-ins.

     \begin{figure}[h!]
      \begin{lstxml}{xml-1}{Authoring a simple \mxp presentation}
<presentation>
  <slide title="Vannevar Bush">
    <bulletlist>
      <item>March 11, 1890 - June 28, 1974</item>
      <item>American Engineer, founder of Raytheon</item>
    </bulletlist>
    <image source="bush.jpg"/>
  </slide>
</presentation>
      \end{lstxml}
     \end{figure}

    \subsubsection{Compiler}

     The compiler has been implemented as a Node.js application. Not only does
     this accomodate the use of the compiler via a web interface or as a web
     service, but projects such as node-webkit also enable the compiler to be
     executed as a local offline desktop application. The decision to use
     server-side JavaScript was influenced by the fact that Node.js has the
     ability to bridge web and desktop technologies. On one hand, the framework
     facilitates interaction with other web services and allows us to work with
     HTML, JSON, XML and JavaScript visualisation libraries during compilation.
     On the other hand, the framework can carry out tasks for which web
     technologies are usually not suitable, including video conversion, legacy
     document format access, file system access or TCP/IP connectivity.

     To enable validation of a \mxp document in the XML format described above,
     an XML Schema exists which is augmented with additional constraints
     provided by the plug-ins. After validating the document, it is parsed and
     any discovered tags might trigger preprocessor actions defined by the
     plug-ins, such as the extraction of data from referenced legacy document
     formats (e.g. \ppt or Excel) or the conversion of an unsupported video
     format. Each tag is then converted to HTML5 and all information is encoded
     in the attributes of a \code{div} element. The HTML5 standard allows
     custom attributes that start with a \code{data-} prefix. \lstref{xml-2}
     shows converted parts of the original XML document we saw in
     \lstref{xml-1}. Observe that no visualisation-specific information is
     included in the transformation, which merely results in a valid HTML5
     document ready to bundle into a self-contained package together with the
     presentation engine.

     \begin{figure}[h!]
      \begin{lstxml}{xml-2}{Transformed HTML5 presentation content}
<div data-type="presentation">
  <div data-type="slide" data-title="Vannevar Bush">
    <div data-type="bulletlist">
      ...
      \end{lstxml}
     \end{figure}

    \subsubsection{Presentation Engine}

   %<TODO rework>
     The presentation engine's task is to turn the compiled HTML content into a
     visually appealing and interactive presentation. As highlighted in
     \figref{roels-1-fig-1}, the presentation engine consists of several
     smaller components which help plug-ins to implement powerful features with
     minimal effort. The combination of these components enables the rapid
     prototyping and evaluation of innovative visualisation ideas. A resulting
     \mxp presentation combining various structure, container and component
     plug-ins is shown in \figref{roels-1-fig-3}.
   %</TODO rework>

     \fig{roels-1-fig-3}{A \mxp presentation}

   %<TODO rework>
     \paragraph{Content Engine} When a presentation is loaded, the content
      engine is the first component that is activated. It processes the content
      of the HTML presentation by making use of the well-known jQuery
      JavaScript library. Whenever a \code{div} element is discovered, the
      \code{data-type} attribute is read and the corresponding plug-ins are
      notified in order to visualise the content.

     \paragraph{Graphics Engine} The graphics engine provides support for
      interesting new visualisation and navigation styles. Next to some basic
      helper functions, it offers efficient panning, scaling and rotation via
      CCS3 transformations and supports zoomable user interfaces as well as the
      more traditional navigation approaches.

     \paragraph{Communication Engine} The communication engine implements
      abstractions that allow plug-ins to retrieve external content at run
      time. It further provides the architectural foundation to form networks
      between different \mxp instances or to integrate third-party hardware
      \citep{roels-2}. For our \mxp prototype, we used a small Intel Next Unit
      of Computing Kit (NUC) with high-end WiFi and Bluetooth modules to act as
      a central access point and provide the underlying network support. \mxp
      instances use WebSockets to communicate with other \mxp instances via the
      access point. The access point further acts as a container for data
      adapters which translate input from third-party input and output devices
      into a generic representation that can be used by the \mxp instances in
      the network. In order to go beyond simple broadcast-based communication,
      we have implemented a routing mechanism based on the publish-subscribe
      pattern where plug-ins can subscribe to specific events or publish
      information. The communication engine provides the basis for audience
      response systems \citep{roels-2} or even full classroom communication
      systems where functionality is only limited by the creativity of plug-in
      developers.

     \paragraph{Plug-ins} Plug-ins are implemented as JavaScript bundles which
      consist of a folder containing JavaScript files and other resources such
      as CSS files, images or other JavaScript libraries. As a first
      convention, a plug-in should provide a manifest file with a predefined
      name. The manifest provides metadata such as the plug-in name and version
      but also a list of tags to be used in a presentation. The plug-in claims
      unique ownership for these tags and is in charge for their visualisation
      if they are encountered by the content engine. As a second convention, a
      plug-in must provide at least one JavaScript file implementing certain
      methods, one of them being the \code{init()} method which is called when
      the plug-in is loaded by the presentation engine. It is up to the plug-in
      to load additional JavaScript or CSS via the provided dependency
      injection functionality. A second method to be implemented is the
      \code{visualise()} method which is invoked with a pointer to the
      corresponding DOM node as a parameter when the content engine encounters
      a tag to be visualised. A plug-in is free to modify the DOM tree and may
      also register callbacks to handle future interaction with the content.

     \paragraph{Themes} We currently use CSS to provide a basic templating
      system. These themes offer styling either on a global or on a plug-in
      level. However, we see this as a temporary solution as it is not
      well-suited for alternative compiler outputs (e.g. PDF) and a more
      generic templating scheme is planned for the future.
   %</TODO rework>

   \subsection{Use Cases}

   %<TODO rework>
    In order to validate the architectural and technological choices, we
    demonstrate the extensibility and feasibility of \mxp as a rapid
    prototyping platform by presenting a number of content- and
    navigation-specific plug-ins that have been developed so far. Additional
    plug-ins for audience-driven functionality such as real-time polls, screen
    mirroring and navigational takeover can be found in \citep{roels-2}.
   %</TODO rework>

    \subsubsection{Structured Overview Plug-in}

   %<TODO rework>
     In Section \ref{mxp-platform} we have explained how structure plug-ins may
     change the way presentations are visualised and navigated. In order to
     illustrate this, we have implemented a structure plug-in called
     \emph{structured layout} which combines a zoomable user interface with the
     ability to group content into sections. The resulting visualisation of the
     \emph{structured layout} plug-in is shown in \figref{roels-1-fig-3}.
     Whenever a new section is reached, the view is zoomed out to provide an
     overview of the content within the section and communicate a sense of
     progress.
   %</TODO rework>

    \subsubsection{Slide Plug-in}

   %<TODO rework>
     In order to also support the traditional slide concept, we created a
     slide-like container plug-in. While the benefits and issues of using
     slides with a fixed size are debatable, we implemented this plug-in as a
     proof of the framework's versatility. The main function of the slide
     plug-in is to provide a rectangular styleable component container with a
     title and some other information. Containers may also offer functionality
     to layout their content. In this case, the slide plug-in offers a quick
     and easy layout mechanism which allows the presenter to partition the
     slide into rows and columns. Content is then assigned to these slots in
     the order that it is discovered. The use of the slide plug-in together
     with the resulting visualisation is exemplified in \lstref{roels-1-fig-4}.
     It also shows the use of the image plug-in (a component plug-in) which
     enables a simple form of cross-media transclusion. A visualised external
     image can be cropped and filters (e.g. colour correction) may be applied
     without duplicating or modifying the original source.
   %</TODO rework>

     \begin{figure}[h!]
      \begin{subfigure}{0.53\textwidth}
       \vspace{-1em}
       \begin{lstxml*}
<slide layout="\60\40" title="Vannevar Bush">
 <bulletlist>
  <item>About
   <item>March 11, 1890 - June 28, 1974</item>
   <item>American Engineer</item>
   <item>Founder of Raytheon</item>
  </item>
  <item>...
  </item>
 </bulletlist>
 <image source="http://example.com/bush.jpg">
  <crop bounds="10%, 5%, -10%, -20%" />
 </image>
</slide>
       \end{lstxml*}
      \end{subfigure}
      \hfill
      \begin{subfigure}{0.43\textwidth}
       \fignl{roels-1-fig-4}
      \end{subfigure}
      \renewcommand{\figurename}{Listing}
      \renewcommand{\figureshortname}{Lst.}
      \cl{roels-1-fig-4}{Slide plug-in}
     \end{figure}

    \subsubsection{Enhanced Video Plug-in}

   %<TODO rework>
     When videos are used in educational settings, we often need more
     functionality than what is offered by the average video player
     \citep{reuss-1}. \mxp provides the enhanced video plug-in shown in
     \lstref{roels-1-fig-5} with the possibility to overlay a video with text
     or arbitrary shapes. This overlay functionality can be used as a basic
     captioning system as well as to highlight items of interest during
     playback.

     Furthermore, we added the option to trigger certain events at specified
     times. One can define that a video should automatically pause at a certain
     point, highlight an object and continue playing after a specified amount
     of time. Additional features include the bookmarking of certain positions
     in a video for direct access or the possibility to display multiple videos
     in a synchronised manner. Our enhanced video plug-in injects the default
     HTML5 video player and overlays it with a transparent \code{div} element
     for augmentation. Currently we make use of the HTML5 video API to
     synchronise the creation and removal of overlays but a SMIL-based
     implementation might be used in the future.
   %</TODO rework>

     \begin{figure}[h!]
      \begin{subfigure}{0.53\textwidth}
       \vspace{-1em}
       \begin{lstxml*}
<video source="vid.mp4">
 <caption start="0:00" duration="1500ms">
  Lecture 3 - Butterfly Species
 </caption>
 <pause start="0:43" duration="5s">
  <caption>
   The peacock butterfly (aglais io) ...
  </caption>
  <highlight x="30%" y="9%"
             width="35%" height="40%" />
 </pause>
</video>
       \end{lstxml*}
      \end{subfigure}
      \hfill
      \begin{subfigure}{0.43\textwidth}
       \fignl{roels-1-fig-5}
      \end{subfigure}
      \renewcommand{\figurename}{Listing}
      \renewcommand{\figureshortname}{Lst.}
      \cl{roels-1-fig-5}{Enhanced video plug-in}
     \end{figure}

 \newpage

    \subsubsection{Source Code Visualisation Plug-in}

   %<TODO rework>
     Earlier, we mentioned the difficulty of visualising complex resources such
     as source code. Our \mxp source code plug-in exports a \code{code} tag
     which allows the presenter to paste their code into a presentation and
     have \mxp visualise it nicely by making use of syntax highlighting via the
     SyntaxHighlighter\footnote{http://alexgorbatchev.com/SyntaxHighlighter/}
     JavaScript library. Whenever the content engine encounters a \code{code}
     tag, it invokes the code plug-in to beautify the code and automatically
     adds vertical scrollbars for larger pieces of source code as shown in
     \lstref{roels-1-fig-6}.
   %</TODO rework>

     \begin{figure}[h!]
      \begin{subfigure}{0.53\textwidth}
       \vspace{-1em}
       \begin{lstxml*}
<code>
 <publications>
  <publication type="inproceedings">
   <title>An Architecture for Open Cross-Media
          Annotation Services</title>
   <author>
     <surname>Signer</surname>
     <forename>Beat</forename>
   </author>
   <author>
     <surname>Norrie</surname>
     <forename>Moira</forename>
   ...
</code>
       \end{lstxml*}
      \end{subfigure}
      \hfill
      \begin{subfigure}{0.43\textwidth}
       \fignl{roels-1-fig-6}
      \end{subfigure}
      \renewcommand{\figurename}{Listing}
      \renewcommand{\figureshortname}{Lst.}
      \cl{roels-1-fig-6}{Source code visualisation}
     \end{figure}

   \subsection{Discussion and Future Work}

   %<TODO rework>
    \mxp currently supports transclusion and cross-media content reuse on the
    plug-in level. For instance, the image or video plug-in can visualise (and
    enhance) external resources, a dictionary plug-in might retrieve
    definitions on demand via a web service or we might create a plug-in that
    allows us to import content (e.g. \ppt slides) from legacy documents at
    compile time. Nevertheless, we are currently investigating the introduction
    of generic reuse tags in our document format which would allow the
    presenter to transclude arbitrary parts of other \mxp presentations. While
    our focus has been on the cross-media aspect of resources that can be used
    in a presentation, we might also investigate the cross-media publishing
    aspect via alternative compiler output formats.

    We are aware that the current authoring of \mxp presentations has some
    usability issues. The average presenter cannot be expected to construct an
    XML document or any CSS themes. In order to tackle this issue and further
    evaluate \mxp in real-life settings, we are currently developing a
    graphical \mxp authoring tool. We further intend to provide a central
    plug-in repository which would make it easy for novice users to find,
    install and use new plug-ins via the authoring tool. In the long run, we
    intend to revise the use of monolithic documents and move towards
    repositories of semantically linked information based on the RSL hypermedia
    metamodel \citep{signer-3}. This would not only promote content reuse and
    sharing, but also create opportunities for context-aware as well as
    semi-automated presentation authoring where relevant content is recommended
    by the authoring tool.
   %</TODO rework>

  \section{Layout}

   Proper layout is incredibly important when trying to transfer knowledge and
   information through written and visual media. Layout can help clarify
   boundaries and relations between pieces of information, by grouping and
   separating them appropriately. Layout is one component of a presentation's
   design, that --- combined with other decisions --- determines the number and
   nature of the visual representations of the information the creator wants to
   communicate, along with its format\footnote{The way the visual objects are
   realised (e.g. as text, graphics, UI widgets\ldots), and their attributes
   (e.g. color, texture, font\ldots)}. The layout of a presentation can have a
   tremenduous influence on its effectiveness in communicating information to,
   and obtaining information from, the audience it is meant to interact with.
   The importance of individual objects can be emphasised or minimised, and the
   connection between obects can be clarified or blurred. A well laid out
   presentation can provide a narrative for the viewer to discover, inferring
   correct links between the objects along the way, and to accomplish tasks
   quickly and correctly, increasing the presentation's effectiveness.

   Creating a good layout is almost never easy. People often spend more time on
   the layout of their presentation than the content. Most, if not all,
   decisions in layout are made by human beings. Some of them are professional
   designers who spend years learning and figuring out how to create effective
   layouts, and even then they may take hours or days to create even a single
   screen of a presentation. In fact, the more someone knows about proper
   layout and design, the more time they may spend perfectioning their work.
   However, sometimes time-critical information must be communicated and the
   layout process is too expensive and too slow to address these situations.
   This can be a serious problem (see also section \ref{nasa}). Many software
   packages have been developed to make this process easier, to get better
   results, to give more or less control to the creators. Many different
   approaches have been taken, and yet most of them still involve having a
   human being make the final decisions on the layout.

   There are tools like \ppt, which give you some guidelines and some templates
   but generally let you do your own thing. If your own thing is entirely
   different from any best practices on layout, nothing will stop you. Other
   tools like \latex give you complete control over every aspect of the layout,
   while setting some sensible defaults so that you can get a good-looking
   layout without much effort, while still letting you do whatever you want
   once you overcome the steep learning curve that separates the casual users
   from the experts. There are tools that combine the power of \latex with the
   comfort of WYSIWYG editors, bringing the casuals a bit closer to the
   experts. But all of those tools have one thing in common: every aspect of
   every layout they create has, at some point, been designed and decided upon
   by a human being.

   Aesthetics are a natural phenomenon, and the creation of aesthetically
   pleasing layouts is therefore a manifestation of our instincts. As with most
   instincts, it has proven difficult to translate this into a concept that can
   be understood by a computer. Moreover, it is still difficult to explain it
   in human terms, which --- according to a popular quote often attributed to
   Albert Einstein --- proves we don't fully understand it ourselves.

   When we look to other technologies, we do find some automated layout
   implementations. For example, the web has had to adapt to mobile devices
   with small screens over the past few years, and has done this gracefully by
   creating the concept of responsive design. In short, this allows websites to
   adapt their layout to any screen, no matter the size. While this is often a
   hard-coded difference, where effectively two or more versions of the same
   webpage are created aimed at different screen sizes, some websites take a
   more dynamic approach based on constraints. As the space the page is to be
   displayed on gets smaller, the layout algorithm may decide to display
   content below other content instead of side-by-side, it may scale images to
   fit the screen, it may even switch fonts and font sizes if necessary.

   This constraint-based technique is described in a few papers
   \citep{lok-1,hurst-1}, but has --- to our knowledge --- not been applied in
   any presentation software so far. This is surprising, as presentations often
   look like they could use some of this magic. A proper constraint-based
   layout algorithm could allow any user to drop content onto a slide, without
   worrying about clarity or even legibility, and the algorithm could take care
   of the rest. Of course, there are some limits in traditional slideware that
   may hinder this approach: if a user decides to put more content on a slide
   than there is physical room available, the algorithm could either make the
   content smaller or split it across several slides, but either solution may
   bring its own problems up. An advantage of ZUI's is that no matter how small
   the content gets, we can still zoom in to make it clear again\footnote{It
   should be noted that \mxp in its current form does not support this level of
   zooming. While the software can zoom out to provide an overview of the
   presentation while zooming in on the separate components, it is not yet
   possible to zoom in or out extremely to reveal 'hidden' parts of the
   presentation. This is something we encourage to look into and change,
   because it can greatly improve both our layout solution as well as the whole
   \mxp experience in general.}.

% maybe TODO more stuff from papers about automated layout goes here

   \subsection{Algorithms}
    \label{related-algorithms}

    When researching layout algorithms, one will often come across the very
    active field of graph layout \citep{battista-1}. We will not go into the
    specifics of this field, as most of the issues with which it is concerned
    are specific to problems caused by the explicit visual representation of
    graph edges --- for example, the minimisation of edge crossing
    \citep{battista-2, shahrokhi-1}. The same applies to automated layout as
    referring to automated circuit layout for VLSI chip fabrication
    \citep{hu-1, lengauer-1} as well as automated placement of pieces to be cut
    from a bolt of cloth used to produce clothing \citep{milenkovic-1}.
    Contrary to presentation layouts (including graph layouts), these layouts
    are designed to meet the requirements of a fabrication process, rather than
    to make them understandable to humans. While some techniques used therein
    definitely apply to our more general problem of automated presentation
    layout (e.g. general constraint solvers) others decidedly do not (e.g.
    bin-packing techniques \citep{hofri-1} that result in minimal area layouts
    at the expense of maintaining visually obvious relationships between
    objects).

